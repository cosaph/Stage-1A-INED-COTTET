[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\nCe site a été créé dans le cadre de mon stage de première année à l’INED. Mon objectif est de rédiger une série d’articles sur l’utilisation de R pour soutenir les chercheurs.es dans leurs travaux.\nR est un langage de programmation et un environnement statistique largement utilisé dans le domaine de la recherche. Il est particulièrement populaire dans les domaines des statistiques, de la bioinformatique, de l’économétrie, de la finance et de l’analyse des données en général."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Cartographie.html",
    "href": "Cartographie.html",
    "title": "Comment réaliser une carte sur R ? Avec mapsf",
    "section": "",
    "text": "Nous allons réaliser des cartes avec R à l’aide du packages install.packages(“mapsf”).\n\nlibrary(mapsf)\n\nWarning: le package 'mapsf' a été compilé avec la version R 4.2.3\n\nlibrary(sf)\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE"
  },
  {
    "objectID": "Package_mapsf/map_sf.html",
    "href": "Package_mapsf/map_sf.html",
    "title": "Mapsf",
    "section": "",
    "text": "Nous allons réaliser des cartes avec R à l’aide du packages install.packages(“mapsf”).\n\nlibrary(mapsf)\n\nWarning: le package 'mapsf' a été compilé avec la version R 4.2.3\n\nlibrary(sf)\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\n\nNous allons réaliser une carte des arrondissments de Paris. J’ai récupérer les données sur le site de Paris Data : https://opendata.paris.fr/pages/catalogue/?disjunctive.theme&disjunctive.publisher\nJe réalise un fond de carte.\n\n# ----- Import des données -----\n\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr' \n  using driver `GeoJSON'\nSimple feature collection with 20 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2.224078 ymin: 48.81558 xmax: 2.469761 ymax: 48.90216\nGeodetic CRS:  WGS 84\n\ncours_deau&lt;-st_read(dsn=\"https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin' \n  using driver `GeoJSON'\nSimple feature collection with 58 features and 25 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.224081 ymin: 48.81924 xmax: 2.450555 ymax: 48.90207\nGeodetic CRS:  WGS 84\n\n\n\n#Dans un premier temps je réalise mon fond de carte avec les arrondissments de Paris \nmf_map(x = arrondissements, border = \"black\") \n\n#Je rajoute les cours d'eau sur mon fond de carte avec l'argument \"add=TRUE\"\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\n\n\n\n\n\n# d'un point de vue esthétique je choisis d'appliquer un fond noir à mes cartes\nmf_theme(\"darkula\")\n\nLes différents type de cartes\n\nLes cartes à symboles proportionels\nLes cartes à symboles proportionnels sont une méthode de représentation graphique utilisée pour visualiser les variables de stocks, ce qui correspond à des variables quantitatives absolues pour lesquelles la somme et la moyenne ont une signification.\n\narrondissements$pop &lt;- c(1012687, 903036, 1369857, 1491027, 1672009, 1506475, 1637163, 1603380, 1637542, 1059282, 1494945, 1436205, 1705774, 1425805, 236769, 1668605, 1674568, 1539668, 1421827, 1829526) #INSEE,2021\nmf_map(x = arrondissements, border = \"black\")\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\nmf_map(\n  x = arrondissements,\n  var = \"pop\",\n  type = \"prop\",\n  leg_title = \"Population totale\\12 271 794\",\n  col=\"#F39487\",\n  add= TRUE\n)\n\nmf_title(\"Distribution de la population dans Paris\")\n\n\n\n\nLes cartes choroplètes\nLes cartes choroplèthes sont une méthode courante de représentation graphique utilisée pour visualiser les variables de ratios, qui correspondent à des variables quantitatives relatives pour lesquelles la moyenne a un sens, mais la somme n’a pas de sens.\n\n#création de la variable densite \narrondissements$DENS &lt;- 1e6 * arrondissements$pop / as.numeric(st_area(arrondissements))\nmf_map(\n  x = arrondissements,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  pal = \"Reds\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0\n)\n\nmf_title(\"Distribution de la population dans Paris (INSEE,2021)\")\n\n\n\n\nOn peut aussi représenter ces variables sous d’autres forme:\n\narr_c&lt;-st_centroid(arrondissements)\n\nWarning: st_centroid assumes attributes are constant over geometries\n\nmf_map(x = arrondissements, border = \"black\")\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\nmf_map(\n  x = arr_c,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  pal = \"Inferno\",\n  pch = 24,\n  cex = 2,\n  border = \"#F29094\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0,\n  add= TRUE\n)\n\n\n\n\nEt si on regroupait deux arrondissemtns ?\nLe code ci-dessous montre la fusion du 15e et 16e arrondissement. L’idée globale du code c’est de fusionner les deux polygones (celui du 15e et du 16e). Ensuite, on recrée toute la ligne de notre tableau de donnée pour pouvoir la fusionner avec celui-ci.\n\n# ---- Fusionner deux polygones ---- #\n\n# Sélectionner les deux polygones que vous souhaitez fusionner\npoly1 &lt;- arrondissements[arrondissements$l_aroff == \"Passy\", ] # sélectionne le polygone avec le nom \"Passy\"\npoly2 &lt;- arrondissements[arrondissements$l_aroff == \"Vaugirard\", ] # sélectionne le polygone avec le nom \"Vaugirard\"\n\n# Fusionner les polygones\nnew_poly &lt;- st_union(poly1, poly2) # fusionne les deux polygones sélectionnés en un seul polygone\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\n# Ajouter la surface, la population, le périmètre et les coordonnées géographiques des deux polygones \n\n#l'idée c'est de recréer une nouvelle ligne pour notre nouveau polygone pour qu'on puisse le reinsérer dans notre tableau. \n\nnew_poly$surface &lt;- new_poly$surface + new_poly$surface.1 # ajouter la surface des deux polygones\nnew_poly$n_sq_co &lt;- new_poly$n_sq_co + new_poly$n_sq_co.1 # ajouter la population des deux polygones\nnew_poly$perimetre &lt;- new_poly$perimetre + new_poly$perimetre.1 # ajouter le périmètre des deux polygones\nnew_poly$n_sq_ar &lt;- new_poly$n_sq_ar + new_poly$n_sq_ar.1 # ajouter les coordonnées géographiques des deux polygones\n\n# Modifier les informations de localisation\nnew_poly$l_aroff &lt;- \"un nouvel arrondissement\" # changer le nom de l'arrondissement\nnew_poly$l_ar &lt;- \"xxème Ardt\" # changer le numéro de l'arrondissement\nnew_poly$c_ar &lt;- \"xx\" # changer le code de l'arrondissement\nnew_poly$c_arinsee &lt;- \"75xxxx\" # changer le code INSEE de la commune\n\n# Sélectionner certaines colonnes pour créer un nouvel objet de données\narrondissements_test &lt;- subset(new_poly, select = c(c_ar, l_aroff, surface, l_ar, n_sq_co, c_arinsee, n_sq_ar, perimetre, geom_x_y))\n# à noter qu'il est très important de mettre les éléments dans le même ordre que celui du tableau\n\n# Remplacer les informations de l'arrondissement \"Passy\" dans l'objet \"arrondissements\" par les nouvelles informations\narrondissements[arrondissements$l_aroff == \"Passy\", ] &lt;- arrondissements_test\n\n# Afficher la carte de l'objet \"arrondissements\" avec les frontières en noir\nmf_map(x = arrondissements, border = \"black\")\n\n\n\n\nPour la rédaction de cet article je me suis grandement inspirée du travail de Timothée Giraud.\nhttps://rcarto.github.io/ined2022/07_mise_en_page.html"
  },
  {
    "objectID": "Package_mapsf/R_cartographie.html",
    "href": "Package_mapsf/R_cartographie.html",
    "title": "Mapview et Oceanis",
    "section": "",
    "text": "Nous allons vous présenter trois packages un peu différent pour obtenir des cartes : sf , mapview et oceanis. Il faut donc au préalable installer ces deux packages. install.packages(“sf”) install.packages(“mapview”) install.packages(“oceanis”) install.packages(“stringr”) #qui sera utiliser pour traiter les données.\n\nlibrary(\"sf\")\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(\"mapview\")\n\nWarning: le package 'mapview' a été compilé avec la version R 4.2.3\n\n\nThe legacy packages maptools, rgdal, and rgeos, underpinning this package\nwill retire shortly. Please refer to R-spatial evolution reports on\nhttps://r-spatial.org/r/2023/05/15/evolution4.html for details.\nThis package is now running under evolution status 0 \n\nlibrary(\"oceanis\")\n\nWarning: le package 'oceanis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : shiny\n\n\nWarning: le package 'shiny' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : shinyBS\n\n\nWarning: le package 'shinyBS' a été compilé avec la version R 4.2.3\n\nlibrary(\"stringr\")\n\nWarning: le package 'stringr' a été compilé avec la version R 4.2.3\n\n\nDans un premier temps nous allons travailler avc mapview. Mapview est une bibliothèque R qui permet d’afficher des données géospatiales interactives et de les explorer facilement. Elle offre une interface graphique conviviale qui permet de zoomer, de déplacer et de sélectionner des données géospatiales à l’aide de la souris.\nNous décidons de travailler sur Paris tout au long de ce tuto.\n\nOn télécharge les données des arrondissements de Paris à partir du site opendata.paris.fr et stocke les données dans l’objet arrondissements sous forme d’un objet de type sf.\n\n\n# Télécharger les données des arrondissements de Paris\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\n\nOn convertit l’objet en un dataframe pour pouvoir travailler dessus.\n\n\n# Convertir l'objet sf en un data.frame\narrondissements_df &lt;- st_drop_geometry(arrondissements)\n\n\nOn supprime les colonnes qui ne sont pas nécessaires pour la représentation spatiale.\n\n\n# Supprimer les colonnes qui ne sont pas nécessaires pour la représentation spatiale\ncols_to_remove &lt;- c(\"datasetid\", \"recordid\", \"fields\", \"geometry_name\", \"type\")\narrondissements_df &lt;- arrondissements_df[, !(names(arrondissements_df) %in% cols_to_remove)]\n\n\nOn convertit les colonnes de type list en caractère et la liste en dataframe/\n\n\n# Convertir les colonnes de type list en caractère\narrondissements_df &lt;- lapply(arrondissements_df, function(x) if (is.list(x)) as.character(x) else x)\n\n# Convertir la liste en data.frame\narrondissements_df &lt;- as.data.frame(arrondissements_df)\n\n\nOn crée un exemple de données df composé de deux colonnes : ‘id’ et ‘coordinates’, où ‘coordinates’ contient les coordonnées de chaque arrondissement.\n\nMes données sont sous la forme d’un vecteur c(a,b). Pour travailler plus simplement je travaille sur la colonne avec le vecteur en question pour créer deux colonnes latitude et longitude.\n\n# Exemple de données\ndf &lt;- data.frame(id = c(1, 2), coordinates = arrondissements_df$geom_x_y)\n\n\n# Diviser la chaîne de caractères à la virgule et extraire la deuxième partie\ncoord_vec &lt;- as.data.frame(strsplit(df$coordinates, \",\"))\ncoord_vec[1,] &lt;- gsub(\"c\", \"\", coord_vec[1,]) # je supprime le c\ncoord_vec[1,] &lt;- gsub('\\\\(', \"\", coord_vec[1,]) # je supprime la parenthèse\ncoord_vec[2,] &lt;- gsub('\\\\)', \"\", coord_vec[2,])\n\n\ncoord_vec[1,]&lt;- as.numeric(coord_vec[1,])\n\ncoord_vec[2,]&lt;- as.numeric(coord_vec[2,])\n\n\ncoord_vec_tranposee&lt;-t(coord_vec)\n\n# Afficher le résultat\narrondissements_df$lon&lt;-coord_vec_tranposee[,1]\narrondissements_df$lat&lt;-coord_vec_tranposee[,2]\n\n\n# Afficher les premières lignes du data.frame\narrondissements_sf &lt;- st_as_sf(arrondissements_df, coords = c(\"lat\",\"lon\"), crs=4326)\n# Retour au format sf pour appliquer la fonction mapview()\nmapview(arrondissements_sf, zcol = c(\"c_ar\",\"l_aroff\"))\n\n\n\n\n\n\nNous allons travailler avec le package Oceanis. Le package oceanis permet de réaliser des cartes d’analyses.\n\nlibrary(oceanis)\n\n\nCréation d’un groupe : Création d’un vecteur d’identifiants de maille pour chaque arrondissement, un vecteur de code de groupe et un vecteur de noms officiels d’arrondissements.\n\n\n# création d'un Groupe\n\n# Créer un vecteur d'identifiants de maille pour chaque arrondissement\nc_ar &lt;- c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\")\n# Créer un groupe \ncode_groupe &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)\n\n# Créer un vecteur de noms officiels d'arrondissements avec les noms que vous avez fournis\nl_aroff &lt;- c(\"Louvre\", \"Bourse\", \"Temple\", \"Hôtel-de-Ville\", \"Panthéon\", \"Luxembourg\", \"Palais-Bourbon\", \"Élysée\", \"Opéra\", \"Enclos-St-Laurent\", \"Popincourt\", \"Reuilly\", \"Gobelins\", \"Observatoire\", \"Vaugirard\", \"Passy\", \"Batignolles-Monceau\", \"Buttes-Montmartre\", \"Buttes-Chaumont\", \"Ménilmontant\")\n\n# Créer un data.frame contenant les trois vecteurs\narrondissements_paris &lt;- data.frame(c_ar, code_groupe, l_aroff)\n\n# Afficher le tableau de données\nprint(arrondissements_paris)\n\n\nCréation d’un zonage à façon des arrondissements de Paris en utilisant la fonction zonage_a_facon() qui prend en entrée les données des arrondissements, le data.frame contenant les identifiants de maille et les codes de groupe, ainsi que les noms officiels d’arrondissements.\n\n\n# Créer le zonage à façon\nze13 &lt;- zonage_a_facon(arrondissements, arrondissements_paris, \"c_ar\", \"code_groupe\", \"l_aroff\")\n\n\nAffichage de la carte avec les identifiants de maille colorés selon leur groupe. Ajout du nom de chaque arrondissement à son centre en créant un vecteur de noms d’arrondissements correspondant aux identifiants de chaque arrondissement. Affichage de la carte avec les noms d’arrondissements. Coloration d’un arrondissement spécifique (le 15e arrondissement) en rouge et les autres en gris, en sélectionnant le polygone correspondant à l’arrondissement 15 et en utilisant la fonction ifelse() pour colorier l’arrondissement 15 en rouge et les autres en gris. Affichage de la carte avec les noms d’arrondissements et l’arrondissement 15 coloré en rouge.\n\n\n# Créer un vecteur de noms d'arrondissements correspondant aux identifiants de chaque arrondissement\nnom_arondissement &lt;- arrondissements_paris$l_aroff[match(ze13$CODE_TERR, arrondissements_paris$code_groupe)]\n\n# Ajouter le nom de chaque arrondissement à son centre\nze13$nom_arondissement &lt;- nom_arondissement\n\n# Afficher la carte avec les noms d'arrondissements\n\n# On va colorier l'arrondissment Vaugirard\n\n# Sélectionner le polygone correspondant à l'arrondissement 15\narrondissement_15 &lt;- ze13[ze13$CODE_TERR == 15, ]\n\n# Afficher la carte avec l'arrondissement 5 en rouge et les autres en gris\nplot(sf::st_geometry(ze13), col = ifelse(ze13$CODE_TERR == 15, \"red\", \"grey\"), border = \"black\", lwd = 1.5)\ntext(sf::st_coordinates(st_centroid(ze13)), labels = ze13$nom_arondissement, cex = 0.8, col = \"black\")\n\nWarning: st_centroid assumes attributes are constant over geometries\n\ntitle(\"Zonage à façon des arrondissements de Paris\")\n\n\n\n\nOn va maintenant essayer de coloriser les arrondissement en fonction de la population. Dans un premier temps on créer une variable population\n\nze13$pop&lt;-c(100196, 95487, 146699, 136591, 58850, 140849, 142462, 118238, 166860, 163445, 139992, 102163, 183399, 169214, 165494, 149500, 144657, 104287, 142005, 100831)\n\nJe fais le choix d’avoir un dégradé de couleur bleu, voici la commande pour l’obtenir:\n\nlibrary(grDevices)\nmycolors &lt;- colorRampPalette(c(\"lightblue\", \"darkblue\"))(20)\n\nPuis je réalise mon plot\n\n# On construit le graphique\nplot(sf::st_geometry(ze13), col = mycolors[cut(ze13$pop, breaks = ze13$pop)], border = \"black\", lwd = 1.5)\n\ntext(sf::st_coordinates(st_centroid(ze13)), labels = ze13$nom_arondissement, cex = 0.8, col = \"white\")\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n# Ajouter une légende\nlegend(\"topright\", \n       title = \"Population\", \n       legend = ze13$nom_arondissement, \n       fill = mycolors[cut(ze13$pop, breaks = ze13$pop)], \n       border = \"black\",\n       box.lwd = 1,\n       cex=0.5) #réduire la taille de la légende\ntitle(\"Zonage à façon des arrondissements de Paris\")\n\n\n\n\nPour les plus aguerries.es on peut utiliser ggplot\n\nlibrary(viridis)\n\nWarning: le package 'viridis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : viridisLite\n\n\nWarning: le package 'viridisLite' a été compilé avec la version R 4.2.3\n\nlibrary(grDevices)\nlibrary(ggplot2)\n\nWarning: le package 'ggplot2' a été compilé avec la version R 4.2.3\n\n# Convertir l'objet sf en un objet ggplot2\nggplot_data &lt;- ggplot() + \n  geom_sf(data = ze13, aes(fill = pop, color = NULL)) + \n  labs(title = \"Zonage à façon des arrondissements de Paris\") + \n  scale_color_viridis(option = \"D\")"
  },
  {
    "objectID": "Nuage_de_mot/nuage_de_mot.html",
    "href": "Nuage_de_mot/nuage_de_mot.html",
    "title": "Nuage de mot (Tm)",
    "section": "",
    "text": "Comme dans tout bon code R il est nécessaire au début d’installer (une fois sur un ordinateur): (dans le terminal de commande ) install.packages(“tm”) # pour le text mining install.packages(“SnowballC”) # pour le text stemming install.packages(“wordcloud”) # générateur de word-cloud install.packages(“RColorBrewer”) # Palettes de couleurs les packages recquis pour le code et de charger (à chaque fois ) les librairies requisent pour le code.\n\n# ---- library ----\nlibrary(\"tm\") # pour le text mining\n\nWarning: le package 'tm' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : NLP\n\nlibrary(\"SnowballC\") # pour le text stemming\n\nWarning: le package 'SnowballC' a été compilé avec la version R 4.2.3\n\nlibrary(\"wordcloud\") # générateur de word-cloud \n\nWarning: le package 'wordcloud' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : RColorBrewer\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\nLe text-mining (ou fouille de texte) est une technique d’analyse de données qui consiste à extraire des informations significatives à partir de données textuelles non structurées telles que des documents, des e-mails, des pages web, des tweets, etc.\nLe stemming est une technique de traitement automatique du langage naturel (TALN) qui consiste à réduire les mots à leur forme racine ou à leur base lexicale, en éliminant les suffixes ou les terminaisons des mots. Par exemple, le stemming pourrait transformer les mots “manger”, “mangeais” et “mangé” en leur forme racine “mang”.\nJ’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# Lire le fichier texte\nfilePath &lt;- \"genre.txt\"\ntext &lt;- readLines(filePath)\n\nWarning in readLines(filePath): ligne finale incomplète trouvée dans\n'genre.txt'\n\n# Charger les données comme un corpus\ndocs &lt;- Corpus(VectorSource(text))\n\nPar la suite, il faut transformer un peu le texte pour ne gardez que l’essentiel, le coeur du sujet. Il faut donc supprimer les “stopword” (le,la,une,des,…).\n\n# ---- Transofrmation du texte ----\n\ntoSpace &lt;- content_transformer(function (x , pattern ) gsub(pattern, \" \", x)) \n\n# Convertir le texte en minuscule\ndocs &lt;- tm_map(docs, content_transformer(tolower)) \n\nWarning in tm_map.SimpleCorpus(docs, content_transformer(tolower)):\ntransformation drops documents\n\n# Supprimer les mots vides anglais\ndocs &lt;- tm_map(docs, removeWords, stopwords(\"fr\"))\n\nWarning in tm_map.SimpleCorpus(docs, removeWords, stopwords(\"fr\")):\ntransformation drops documents\n\n# Supprimer votre propre liste de mots non désirés\ndocs &lt;- tm_map(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")) \n\nWarning in tm_map.SimpleCorpus(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")):\ntransformation drops documents\n\n# Supprimer les ponctuations\ndocs &lt;- tm_map(docs, removePunctuation)\n\nWarning in tm_map.SimpleCorpus(docs, removePunctuation): transformation drops\ndocuments\n\n# Supprimer les espaces vides supplémentaires\ndocs &lt;- tm_map(docs, stripWhitespace)\n\nWarning in tm_map.SimpleCorpus(docs, stripWhitespace): transformation drops\ndocuments\n\ninspect(docs) #inspecter le document\n\nS’il on veut supprimer des nombres, on utilise la syntaxe : “docs &lt;- tm_map(docs, removeNumbers)”\nOn réalise ensuite une table de fréquence d’apparition des mots\n::: {.cell}\n# table de fréquence de mot (voir table d'occurence)\ndtm &lt;- TermDocumentMatrix(docs)\nm &lt;- as.matrix(dtm)\nv &lt;- sort(rowSums(m),decreasing=TRUE)\nd &lt;- data.frame(word = names(v),freq=v)\nhead(d, 12) # affiche les 12 mots avec les plus grosses fréquences. \n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=brewer.pal(8, \"Paired\")) #réalisation du nuage de mots.\n::: {.cell-output-display}  :::\n# On pourrait faire quelque chose de beaucoup plus neutre en terme de couleur avec la commande :\n\n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=\"black\")\n::: {.cell-output-display}  ::: :::\nC’est quoi le set.seed(1234) ? Lorsque vous utilisez une graine aléatoire (le set.seed(1234)), cela garantit que les résultats de votre analyse seront les mêmes à chaque fois que vous exécutez le code. Cela est particulièrement important lorsque vous travaillez avec des fonctions qui impliquent une certaine forme d’aléatoire, comme la génération de nuages de mots.\nAinsi, si vous utilisez la même graine aléatoire (par exemple, 1234) dans votre code chaque fois que vous exécutez l’analyse, vous obtiendrez toujours les mêmes résultats, ce qui facilite la reproductibilité de votre analyse. Sans fixer la graine aléatoire, la génération du nuage de mots peut varier à chaque exécution, car les fonctions qui génèrent le nuage de mots utilisent généralement des algorithmes aléatoires pour placer les mots dans l’espace et choisir les couleurs. Cela signifie que chaque fois que vous exécutez le code, vous obtiendrez un nuage de mots différent, même si les données d’entrée sont les mêmes.\nPour en apprendre plus sur la constrcution des images de mots : http://www.sthda.com/french/wiki/text-mining-et-nuage-de-mots-avec-le-logiciel-r-5-etapes-simples-a-savoir"
  },
  {
    "objectID": "Nuage_de_mot/nuage_de_mot_rtemis.html",
    "href": "Nuage_de_mot/nuage_de_mot_rtemis.html",
    "title": "Nuage de mot (R.temis)",
    "section": "",
    "text": "# ----- Librairies ----\nlibrary(\"R.temis\")\n\nWarning: le package 'R.temis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : tm\n\n\nWarning: le package 'tm' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : NLP\n\n\nLe chargement a nécessité le package : slam\n\n\nLe chargement a nécessité le package : FactoMineR\n\n\nWarning: le package 'FactoMineR' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : explor\n\n\nWarning: le package 'explor' a été compilé avec la version R 4.2.3\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\n(N’oubliez pas d’installer les packages avant d’exéctuer les libraries si ceux-ci sont nouveaux!) Concernant le choix des données, j’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# ---- Import des données ----\n\ncorpus &lt;- import_corpus(\"genre.csv\",format=\"csv\",textcolumn=1,language=\"fr\")\n\nC’est quoi les stop_words?\nLes stop words (ou mots vides) sont des mots très courants dans un langage donné, comme les prépositions, les articles, les pronoms, etc., qui sont souvent omis lors de l’analyse de texte car ils ne portent pas de sens important pour la compréhension globale du texte.\n\n# ---- traitement des données ----\ndtmsmo &lt;-build_dtm(corpus, remove_stopwords = T, min_length = 0)\n\ndic &lt;-dictionary(dtmsmo) #création d'un dictionnaire de mot \n\nfrequent_terms(dtmsmo) #fréquence d'apparition des mots dans le texte en question\n\nIl est possible de faire un traitement plus poussé des données\n\n# ---- Générateur du Nuage ---- \ncloud&lt;-word_cloud(dtmsmo, color=brewer.pal(10, \"OrRd\"), min.freq=0) \n\nWarning in brewer.pal(10, \"OrRd\"): n too large, allowed maximum for palette OrRd is 9\nReturning the palette you asked for with that many colors\n\n\n\n\nterms_graph(dtmsmo, min_occ=1,interactive=T) #pour obtenir un graph de mots.\n\n[1] 1"
  },
  {
    "objectID": "Package_purrr/package_purrr.html",
    "href": "Package_purrr/package_purrr.html",
    "title": "Package Purrr",
    "section": "",
    "text": "purrr est un package dédié à la programmation fonctionnelle. Ses fonctions principales sont les fonctions map() (map(), map_chr(), map_dbl(), map_dfr(), etc…), elles permettent d’appliquer une même fonction (ou une même série de fonctions) à chaque élément d’un ensemble (les colonnes d’un data frame, ou les éléments d’une list par exemple). En gros, ces fonctions map() permettent de remplacer les boucles for() avantageusement en termes de nombre de lignes de code et de temps de calcul (parce que ces fonctions reposent sur la récursivité).\n\nlibrary(purrr) \n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nA titre d’exemple on va essayer de supposer que nous avons une liste de vecteurs numériques et que nous allons appliquer une fonction à chaque vecteur pour en extraire la valeur maximale. Sans le package purr il est nécessaire d’utiliser une boucle for:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Initialiser un vecteur vide pour stocker les résultats\nmax_vals &lt;- numeric(length(my_list))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nfor (i in seq_along(my_list)) {\n  max_vals[i] &lt;- max(my_list[[i]])\n}\n# Afficher les résultats\nmax_vals\n\n[1] 3 6 9\n\n\nAvec le package purrr:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nmax_vals &lt;- map(my_list, max)\n\n# Afficher les résultats\nmax_vals\n\non remarque qu’on gagne quand même pas mal de temps d’écriture en utilisant le package purrr, ce qui peut vraiment servir quand on a de pas mal de ligne de code.\n\n\nPour en apprendre plus sur le package purr :\nhttps://delladata.fr/liste-de-ressources-pour-le-package-purrr/"
  },
  {
    "objectID": "Package_rio/Rio_package.html",
    "href": "Package_rio/Rio_package.html",
    "title": "Package Rio",
    "section": "",
    "text": "L’import de données est la base de tout programme informatique portant sur le traitement de données. Le package “rio” est une collection de fonctions pour importer et exporter des données dans différents formats avec R. Il permet d’importer facilement des fichiers de données à partir de diverses sources, notamment des fichiers plats, des bases de données, des fichiers SAS, SPSS et Stata, ainsi que des fichiers Excel et RData. Il faut au préalable installer le package avec la commande suivante: ” install.packages(“rio”)“.\n\n# ---- Librairie ---- \n\nlibrary(rio)\n\nWarning: le package 'rio' a été compilé avec la version R 4.2.3\n\ninstall_formats()\n\n[1] TRUE\n\n# --- import de données --- \n\n#Pour des données au format xlsx\n\ndata_xslx&lt;-import(\"election_leg.xlsx\") \n\n\n#Pour des données au format SAS (ou autre), c'est la même chose.\ndata_sas&lt;-import(\"chemin_d_acces.sas7bdat\")\n\nPour exporter une base de données dans un fichier, il est recommandé d’utiliser la méthode “export” en utilisant le dataframe que vous voulez exporter, ici “data_sas” (comme illustré ci-dessous), et en spécifiant le chemin où vous souhaitez le sauvegarder. Cette méthode est généralement utilisée lorsque vous apportez des modifications directes à votre dataframe et que vous souhaitez enregistrer les changements quelque part.\n\n# --- export de données ---\n\nchemin_acces&lt;-export(data_sas,\"election_leg.xlsx\")\n\nPour en apprendre plus sur le package rio https://rdocumentation.org/packages/rio/versions/0.5.29\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "Package_dplyr/quarto_dplyr.html",
    "href": "Package_dplyr/quarto_dplyr.html",
    "title": "Package Dplyr",
    "section": "",
    "text": "Nous utiliserons dplyr comme package. dplyr est une grammaire de manipulation de données, fournissant un ensemble cohérent de verbes qui vous aide à résoudre les problèmes de manipulation de données les plus courants. https://www.rdocumentation.org/packages/dplyr/versions/0.7.8\n\n# ---- Librairie nécessaire pour le code ----\nlibrary(dplyr) \n\nWarning: le package 'dplyr' a été compilé avec la version R 4.2.3\n\nlibrary(tidyverse) #pour utiliser \"%&gt;%\" (ou pipe) définit en dessous\n\nWarning: le package 'tidyverse' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'ggplot2' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'tibble' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'stringr' a été compilé avec la version R 4.2.3\n\n\nUne fois la librairie importée, nous devons importer les donnés pour pouvoir travailler dessus. Nous utilisons ici un exemple de fichier de traitement de données portant sur le titanic. Nous utiliserons le package Rio pour les importer.\n\ndata(starwars)\n\nMais comment puis-je filtrer ma table pour n’obtenir que les passagers situé dans la classe 2 à bord du titanic ?\nLe “pipe” ou opérateur “%&gt;%” en R permet d’enchaîner les opérations sur une table sans avoir à répéter le nom de la table à chaque étape. Cela simplifie la syntaxe et rend le code plus lisible en permettant d’écrire des enchaînements d’opérations sur une table de manière plus concise et efficace.\n\nstarwars&lt;-starwars %&gt;% filter(species==\"Human\")\n# sans l'opérateur %&gt;% on aurait : \nstarwars_filtered &lt;- filter(starwars, species == \"Human\")\n# une autre façon de filter sans utiliser le package dplyr est \nstarwars_filtered &lt;- starwars[starwars$species == \"Human\", ]\n\nComment est-ce que je peut ajouter des données à mon dataframe?\n\n#avec dplyr on utilise la fonction mutate() pour ajouter des colonnes\n# a notre dataframe. Pour afficher la nouvelle colonne dans le dataframe \n#on rajoute la commande select(nouvelle_colonne,everything())\nstarwars %&gt;% mutate(moyenne=mean(is.na(mass))) %&gt;% select(moyenne,everything())\n\nComment est-ce que je peux selectionner uniquement les colonnes qui m’interesse pour mon travail?\n\nstarwars %&gt;% select(species,gender) #on selectionne ici l'espèce et le genre\n\nComment est-ce que je peux grouper mes données ?\n\nstarwars %&gt;% group_by(species) # regroupe par espèce\n\n#La fonction tapply() est une autre fonction de base de R \n#qui permet de regrouper les données selon une ou plusieurs variables\navg_height_by_species &lt;- tapply(starwars$height, starwars$species, mean, na.rm = TRUE)\n\n#La fonction aggregate() est une fonction de base de R qui permet de regrouper les données selon une ou plusieurs variables \navg_height_by_species &lt;- aggregate(starwars$height, by = list(starwars$species), FUN = mean, na.rm = TRUE)\n\nPour en apprendre plus sur dplyr :\nhttps://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html"
  },
  {
    "objectID": "R/Nuage_de_mot/nuage_de_mot.html",
    "href": "R/Nuage_de_mot/nuage_de_mot.html",
    "title": "Nuage de mot (Tm)",
    "section": "",
    "text": "Comme dans tout bon code R il est nécessaire au début d’installer (une fois sur un ordinateur): (dans le terminal de commande ) install.packages(“tm”) # pour le text mining install.packages(“SnowballC”) # pour le text stemming install.packages(“wordcloud”) # générateur de word-cloud install.packages(“RColorBrewer”) # Palettes de couleurs les packages recquis pour le code et de charger (à chaque fois ) les librairies requisent pour le code.\n\n# ---- library ----\nlibrary(\"tm\") # pour le text mining\n\nWarning: le package 'tm' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : NLP\n\nlibrary(\"SnowballC\") # pour le text stemming\n\nWarning: le package 'SnowballC' a été compilé avec la version R 4.2.3\n\nlibrary(\"wordcloud\") # générateur de word-cloud \n\nWarning: le package 'wordcloud' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : RColorBrewer\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\nLe text-mining (ou fouille de texte) est une technique d’analyse de données qui consiste à extraire des informations significatives à partir de données textuelles non structurées telles que des documents, des e-mails, des pages web, des tweets, etc.\nLe stemming est une technique de traitement automatique du langage naturel (TALN) qui consiste à réduire les mots à leur forme racine ou à leur base lexicale, en éliminant les suffixes ou les terminaisons des mots. Par exemple, le stemming pourrait transformer les mots “manger”, “mangeais” et “mangé” en leur forme racine “mang”.\nJ’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# Lire le fichier texte\nfilePath &lt;- \"genre.txt\"\ntext &lt;- readLines(filePath)\n\nWarning in readLines(filePath): ligne finale incomplète trouvée dans\n'genre.txt'\n\n# Charger les données comme un corpus\ndocs &lt;- Corpus(VectorSource(text))\n\nPar la suite, il faut transformer un peu le texte pour ne gardez que l’essentiel, le coeur du sujet. Il faut donc supprimer les “stopword” (le,la,une,des,…).\n\n# ---- Transofrmation du texte ----\n\ntoSpace &lt;- content_transformer(function (x , pattern ) gsub(pattern, \" \", x)) \n\n# Convertir le texte en minuscule\ndocs &lt;- tm_map(docs, content_transformer(tolower)) \n\nWarning in tm_map.SimpleCorpus(docs, content_transformer(tolower)):\ntransformation drops documents\n\n# Supprimer les mots vides anglais\ndocs &lt;- tm_map(docs, removeWords, stopwords(\"fr\"))\n\nWarning in tm_map.SimpleCorpus(docs, removeWords, stopwords(\"fr\")):\ntransformation drops documents\n\n# Supprimer votre propre liste de mots non désirés\ndocs &lt;- tm_map(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")) \n\nWarning in tm_map.SimpleCorpus(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")):\ntransformation drops documents\n\n# Supprimer les ponctuations\ndocs &lt;- tm_map(docs, removePunctuation)\n\nWarning in tm_map.SimpleCorpus(docs, removePunctuation): transformation drops\ndocuments\n\n# Supprimer les espaces vides supplémentaires\ndocs &lt;- tm_map(docs, stripWhitespace)\n\nWarning in tm_map.SimpleCorpus(docs, stripWhitespace): transformation drops\ndocuments\n\ninspect(docs) #inspecter le document\n\nS’il on veut supprimer des nombres, on utilise la syntaxe : “docs &lt;- tm_map(docs, removeNumbers)”\nOn réalise ensuite une table de fréquence d’apparition des mots\n::: {.cell}\n# table de fréquence de mot (voir table d'occurence)\ndtm &lt;- TermDocumentMatrix(docs)\nm &lt;- as.matrix(dtm)\nv &lt;- sort(rowSums(m),decreasing=TRUE)\nd &lt;- data.frame(word = names(v),freq=v)\nhead(d, 12) # affiche les 12 mots avec les plus grosses fréquences. \n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=brewer.pal(8, \"Paired\")) #réalisation du nuage de mots.\n::: {.cell-output-display}  :::\n# On pourrait faire quelque chose de beaucoup plus neutre en terme de couleur avec la commande :\n\n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=\"black\")\n::: {.cell-output-display}  ::: :::\nC’est quoi le set.seed(1234) ? Lorsque vous utilisez une graine aléatoire (le set.seed(1234)), cela garantit que les résultats de votre analyse seront les mêmes à chaque fois que vous exécutez le code. Cela est particulièrement important lorsque vous travaillez avec des fonctions qui impliquent une certaine forme d’aléatoire, comme la génération de nuages de mots.\nAinsi, si vous utilisez la même graine aléatoire (par exemple, 1234) dans votre code chaque fois que vous exécutez l’analyse, vous obtiendrez toujours les mêmes résultats, ce qui facilite la reproductibilité de votre analyse. Sans fixer la graine aléatoire, la génération du nuage de mots peut varier à chaque exécution, car les fonctions qui génèrent le nuage de mots utilisent généralement des algorithmes aléatoires pour placer les mots dans l’espace et choisir les couleurs. Cela signifie que chaque fois que vous exécutez le code, vous obtiendrez un nuage de mots différent, même si les données d’entrée sont les mêmes.\nPour en apprendre plus sur la constrcution des images de mots : http://www.sthda.com/french/wiki/text-mining-et-nuage-de-mots-avec-le-logiciel-r-5-etapes-simples-a-savoir"
  },
  {
    "objectID": "R/Nuage_de_mot/nuage_de_mot_rtemis.html",
    "href": "R/Nuage_de_mot/nuage_de_mot_rtemis.html",
    "title": "Générer un nuage de mot à partir d’un texte avec R.temis",
    "section": "",
    "text": "1. Travail préliminaire\nComme dans tout bon code R il est nécessaire au début d’installer (une fois sur un ordinateur): (dans le terminal de commande ) install.packages(“R.temis”) install.packages(“RColorBrewer”) # Palettes de couleurs les packages recquis pour le code et de charger (à chaque fois ) les librairies requisent pour le code.\n\nlibrary(\"R.temis\")\nlibrary(\"dplyr\")\nlibrary(\"tibble\")\n\nConcernant le choix des données, j’ai choisis les voeux d’Emmanuel Macron pour l’année 2021,2022,2023.\n\ncorpus &lt;- import_corpus(\"texte\", format=\"txt\", language =\"fr\")\n\n\n\n2. Nettoyage du texte\nC’est quoi les stop_words?\nLes stop words (ou mots vides) sont des mots très courants dans un langage donné, comme les prépositions, les articles, les pronoms, etc., qui sont souvent omis lors de l’analyse de texte car ils ne portent pas de sens important pour la compréhension globale du texte.\nLa fonction build_dtm est utilisée pour construire une matrice de termes-document à partir d’un corpus de textes. La matrice de termes-document est une représentation quantitative des termes présents dans un corpus de textes, où chaque ligne représente un terme et chaque colonne représente un document.\n\n# ---- traitement des données ----\ndtm &lt;-build_dtm(corpus, remove_stopwords = T, min_length = 0)\n\ndic &lt;-dictionary(dtm) #création d'un dictionnaire de mot \n\nfrequent_terms(dtm) #fréquence apparition des mots dans le texte en question\n\n             Global occ.   Global %\ne                   3089 17.1821115\n                    1176  6.5413283\nr                    218  1.2125932\nplus                 200  1.1124708\na                    157  0.8732896\nfrance               139  0.7731672\nea                   136  0.7564801\naussi                111  0.6174213\nann                  103  0.5729225\ntous                 103  0.5729225\nf                     96  0.5339860\npays                  94  0.5228613\npr                    83  0.4616754\ntout                  75  0.4171765\nc                     71  0.3949271\nfaire                 71  0.3949271\ncomme                 69  0.3838024\nv                     69  0.3838024\ntre                   65  0.3615530\ncontre                60  0.3337412\nre                    59  0.3281789\nfran                  58  0.3226165\ntravail               58  0.3226165\ncompatriotes          53  0.2948048\neurope                52  0.2892424\n\n\n\n\n3. Traitement du corpus\nJ’aimerai retirer le mot “a”, ” “,”e”,“c”,“v”,“re”,“pr”,“ea”,“r” à titre d’exemple\n\ndic2 = dic %&gt;%\n  rownames_to_column(var=\"word\") %&gt;% \n  mutate(Term = word)\n\nrow.names(dic2) &lt;- dic2$word\n\n# Remplacer les mots spécifiés par \"Année\"\ndic2$Term[dic2$word == \"ann\"] &lt;- \"Année\"\ndic2$Term[dic2$word == \"année\"] &lt;- \"Année\"\ndic2$Term[dic2$word == \"an\"] &lt;- \"Année\"\n\n\ndic2$Term[dic2$word == \"tre\"] &lt;- \"très\"\ndic2$Term[dic2$word == \"france\"] &lt;- \"France\"\n\ndtmlem &lt;-combine_terms(dtm, dic2)\n\nmots_a_retirer &lt;- c(\"a\", \" \", \"e\", \"c\", \"v\", \"re\", \"pr\", \"ea\", \"r\",\"o\",\"f\")\n\ndtm2&lt;-dtmlem[, !colnames(dtmlem) %in% mots_a_retirer]\n\n\nfrequent_terms(dtm2)\n\n             Global occ.  Global %\n                    1176 8.4228621\nplus                 200 1.4324595\nAnnée                146 1.0456955\nFrance               139 0.9955594\naussi                111 0.7950150\ntous                 103 0.7377167\npays                  94 0.6732560\ntout                  75 0.5371723\nfaire                 71 0.5085231\ncomme                 69 0.4941985\ntrès                  65 0.4655493\ncontre                60 0.4297379\nfran                  58 0.4154133\ntravail               58 0.4154133\ncompatriotes          53 0.3796018\neurope                52 0.3724395\nveux                  50 0.3581149\nvie                   50 0.3581149\nchacun                48 0.3437903\nentre                 48 0.3437903\ndoit                  45 0.3223034\nalors                 44 0.3151411\nsoir                  44 0.3151411\nceux                  43 0.3079788\nnation                43 0.3079788\n\n\n\n\n4. Construction du Nuage\n\ncloud&lt;-word_cloud(dtm2, color= 'black', min.freq=1,n =50) \n\n\n\n\n\n\n5. Analyse descriptive\nLa fonction terms_graph du package R.temis permet de générer un réseau de mots qui est affiché dans une fenêtre interactive igraph. Les termes ou mots sont représentés par des sommets ou nœuds dans le graphe. Leur placement dans l’espace graphique est déterminé par un algorithme d’énergie, qui prend en compte les co-occurrences des termes dans le corpus. Les liens dans le graphe représentent les co-occurrences entre les termes. Ici,ce n’est pas très représentatif mais ça donne globalement une idée de ce que peut nous fournir un tel graphe: l’idée globale des thématiques et des sujets traités dans le corpus.\n\n# Créer un graphique d'analyse de co-occurrences de termes\nTree&lt;-terms_graph(dtm2, min_occ = 50, interactive = T,\n            vertex.size = 0.01, vertex.color = \"lightblue\",\n            label.cex = 0.1)\n\n\n\n\n6. Pour aller plus loin\nhttps://rtemis.hypotheses.org/r-temis-dans-rstudio"
  },
  {
    "objectID": "R/Package_dplyr/quarto_dplyr.html",
    "href": "R/Package_dplyr/quarto_dplyr.html",
    "title": "Faciliter la manipulation de données avec Dplyr",
    "section": "",
    "text": "Nous utiliserons dplyr comme package. dplyr est une grammaire de manipulation de données, fournissant un ensemble cohérent de verbes qui vous aide à résoudre les problèmes de manipulation de données les plus courants. https://www.rdocumentation.org/packages/dplyr/versions/0.7.8\n\n# ---- Librairie nécessaire pour le code ----\nlibrary(dplyr) \n\nWarning: le package 'dplyr' a été compilé avec la version R 4.2.3\n\nlibrary(tidyverse) #pour utiliser \"%&gt;%\" (ou pipe) définit en dessous\n\nWarning: le package 'tidyverse' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'ggplot2' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'tibble' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'stringr' a été compilé avec la version R 4.2.3\n\n\nUne fois la librairie importée, nous devons importer les donnés pour pouvoir travailler dessus. Nous utilisons ici un exemple de fichier de traitement de données portant sur le titanic. Nous utiliserons le package Rio pour les importer.\n\ndata(starwars)\n\nMais comment puis-je filtrer ma table pour n’obtenir que les passagers situé dans la classe 2 à bord du titanic ?\nLe “pipe” ou opérateur “%&gt;%” en R permet d’enchaîner les opérations sur une table sans avoir à répéter le nom de la table à chaque étape. Cela simplifie la syntaxe et rend le code plus lisible en permettant d’écrire des enchaînements d’opérations sur une table de manière plus concise et efficace.\n\nstarwars&lt;-starwars %&gt;% filter(species==\"Human\")\n# sans l'opérateur %&gt;% on aurait : \nstarwars_filtered &lt;- filter(starwars, species == \"Human\")\n# une autre façon de filter sans utiliser le package dplyr est \nstarwars_filtered &lt;- starwars[starwars$species == \"Human\", ]\n\nComment est-ce que je peut ajouter des données à mon dataframe?\n\n#avec dplyr on utilise la fonction mutate() pour ajouter des colonnes\n# a notre dataframe. Pour afficher la nouvelle colonne dans le dataframe \n#on rajoute la commande select(nouvelle_colonne,everything())\nstarwars %&gt;% mutate(moyenne=mean(is.na(mass))) %&gt;% select(moyenne,everything())\n\nComment est-ce que je peux selectionner uniquement les colonnes qui m’interesse pour mon travail?\n\nstarwars %&gt;% select(species,gender) #on selectionne ici l'espèce et le genre\n\nComment est-ce que je peux grouper mes données ?\n\nstarwars %&gt;% group_by(species) # regroupe par espèce\n\n#La fonction tapply() est une autre fonction de base de R \n#qui permet de regrouper les données selon une ou plusieurs variables\navg_height_by_species &lt;- tapply(starwars$height, starwars$species, mean, na.rm = TRUE)\n\n#La fonction aggregate() est une fonction de base de R qui permet de regrouper les données selon une ou plusieurs variables \navg_height_by_species &lt;- aggregate(starwars$height, by = list(starwars$species), FUN = mean, na.rm = TRUE)\n\nPour en apprendre plus sur dplyr :\nhttps://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html"
  },
  {
    "objectID": "R/Package_mapsf/map_sf.html",
    "href": "R/Package_mapsf/map_sf.html",
    "title": "Mapsf",
    "section": "",
    "text": "Nous allons réaliser des cartes avec R à l’aide du packages install.packages(“mapsf”).\n\nlibrary(mapsf)\n\nWarning: le package 'mapsf' a été compilé avec la version R 4.2.3\n\nlibrary(sf)\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\n\nNous allons réaliser une carte des arrondissments de Paris. J’ai récupérer les données sur le site de Paris Data : https://opendata.paris.fr/pages/catalogue/?disjunctive.theme&disjunctive.publisher\nJe réalise un fond de carte.\n\n# ----- Import des données -----\n\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr' \n  using driver `GeoJSON'\nSimple feature collection with 20 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2.224078 ymin: 48.81558 xmax: 2.469761 ymax: 48.90216\nGeodetic CRS:  WGS 84\n\ncours_deau&lt;-st_read(dsn=\"https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin' \n  using driver `GeoJSON'\nSimple feature collection with 58 features and 25 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.224081 ymin: 48.81924 xmax: 2.450555 ymax: 48.90207\nGeodetic CRS:  WGS 84\n\n\n\n#Dans un premier temps je réalise mon fond de carte avec les arrondissments de Paris \nmf_map(x = arrondissements, border = \"black\") \n\n#Je rajoute les cours d'eau sur mon fond de carte avec l'argument \"add=TRUE\"\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\n\n\n\n\n\n# d'un point de vue esthétique je choisis d'appliquer un fond noir à mes cartes\nmf_theme(\"darkula\")\n\nLes différents type de cartes\n\nLes cartes à symboles proportionels\nLes cartes à symboles proportionnels sont une méthode de représentation graphique utilisée pour visualiser les variables de stocks, ce qui correspond à des variables quantitatives absolues pour lesquelles la somme et la moyenne ont une signification.\n\narrondissements$pop &lt;- c(1012687, 903036, 1369857, 1491027, 1672009, 1506475, 1637163, 1603380, 1637542, 1059282, 1494945, 1436205, 1705774, 1425805, 236769, 1668605, 1674568, 1539668, 1421827, 1829526) #INSEE,2021\nmf_map(x = arrondissements, border = \"black\")\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\nmf_map(\n  x = arrondissements,\n  var = \"pop\",\n  type = \"prop\",\n  leg_title = \"Population totale\\12 271 794\",\n  col=\"#F39487\",\n  add= TRUE\n)\n\nmf_title(\"Distribution de la population dans Paris\")\n\n\n\n\nLes cartes choroplètes\nLes cartes choroplèthes sont une méthode courante de représentation graphique utilisée pour visualiser les variables de ratios, qui correspondent à des variables quantitatives relatives pour lesquelles la moyenne a un sens, mais la somme n’a pas de sens.\n\n#création de la variable densite \narrondissements$DENS &lt;- 1e6 * arrondissements$pop / as.numeric(st_area(arrondissements))\nmf_map(\n  x = arrondissements,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  pal = \"Reds\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0\n)\n\nmf_title(\"Distribution de la population dans Paris (INSEE,2021)\")\n\n\n\n\nOn peut aussi représenter ces variables sous d’autres forme:\n\narr_c&lt;-st_centroid(arrondissements)\n\nWarning: st_centroid assumes attributes are constant over geometries\n\nmf_map(x = arrondissements, border = \"black\")\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\nmf_map(\n  x = arr_c,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  pal = \"Inferno\",\n  pch = 24,\n  cex = 2,\n  border = \"#F29094\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0,\n  add= TRUE\n)\n\n\n\n\nEt si on regroupait deux arrondissemtns ?\nLe code ci-dessous montre la fusion du 15e et 16e arrondissement. L’idée globale du code c’est de fusionner les deux polygones (celui du 15e et du 16e). Ensuite, on recrée toute la ligne de notre tableau de donnée pour pouvoir la fusionner avec celui-ci.\n\n# ---- Fusionner deux polygones ---- #\n\n# Sélectionner les deux polygones que vous souhaitez fusionner\npoly1 &lt;- arrondissements[arrondissements$l_aroff == \"Passy\", ] # sélectionne le polygone avec le nom \"Passy\"\npoly2 &lt;- arrondissements[arrondissements$l_aroff == \"Vaugirard\", ] # sélectionne le polygone avec le nom \"Vaugirard\"\n\n# Fusionner les polygones\nnew_poly &lt;- st_union(poly1, poly2) # fusionne les deux polygones sélectionnés en un seul polygone\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\n# Ajouter la surface, la population, le périmètre et les coordonnées géographiques des deux polygones \n\n#l'idée c'est de recréer une nouvelle ligne pour notre nouveau polygone pour qu'on puisse le reinsérer dans notre tableau. \n\nnew_poly$surface &lt;- new_poly$surface + new_poly$surface.1 # ajouter la surface des deux polygones\nnew_poly$n_sq_co &lt;- new_poly$n_sq_co + new_poly$n_sq_co.1 # ajouter la population des deux polygones\nnew_poly$perimetre &lt;- new_poly$perimetre + new_poly$perimetre.1 # ajouter le périmètre des deux polygones\nnew_poly$n_sq_ar &lt;- new_poly$n_sq_ar + new_poly$n_sq_ar.1 # ajouter les coordonnées géographiques des deux polygones\n\n# Modifier les informations de localisation\nnew_poly$l_aroff &lt;- \"un nouvel arrondissement\" # changer le nom de l'arrondissement\nnew_poly$l_ar &lt;- \"xxème Ardt\" # changer le numéro de l'arrondissement\nnew_poly$c_ar &lt;- \"xx\" # changer le code de l'arrondissement\nnew_poly$c_arinsee &lt;- \"75xxxx\" # changer le code INSEE de la commune\n\n# Sélectionner certaines colonnes pour créer un nouvel objet de données\narrondissements_test &lt;- subset(new_poly, select = c(c_ar, l_aroff, surface, l_ar, n_sq_co, c_arinsee, n_sq_ar, perimetre, geom_x_y))\n# à noter qu'il est très important de mettre les éléments dans le même ordre que celui du tableau\n\n# Remplacer les informations de l'arrondissement \"Passy\" dans l'objet \"arrondissements\" par les nouvelles informations\narrondissements[arrondissements$l_aroff == \"Passy\", ] &lt;- arrondissements_test\n\n# Afficher la carte de l'objet \"arrondissements\" avec les frontières en noir\nmf_map(x = arrondissements, border = \"black\")\n\n\n\n\nPour la rédaction de cet article je me suis grandement inspirée du travail de Timothée Giraud.\nhttps://rcarto.github.io/ined2022/07_mise_en_page.html"
  },
  {
    "objectID": "R/Package_mapsf/R_cartographie.html",
    "href": "R/Package_mapsf/R_cartographie.html",
    "title": "Mapview et Oceanis",
    "section": "",
    "text": "Nous allons vous présenter trois packages un peu différent pour obtenir des cartes : sf , mapview et oceanis. Il faut donc au préalable installer ces deux packages. install.packages(“sf”) install.packages(“mapview”) install.packages(“oceanis”) install.packages(“stringr”) #qui sera utiliser pour traiter les données.\n\nlibrary(\"sf\")\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(\"mapview\")\n\nWarning: le package 'mapview' a été compilé avec la version R 4.2.3\n\n\nThe legacy packages maptools, rgdal, and rgeos, underpinning this package\nwill retire shortly. Please refer to R-spatial evolution reports on\nhttps://r-spatial.org/r/2023/05/15/evolution4.html for details.\nThis package is now running under evolution status 0 \n\nlibrary(\"oceanis\")\n\nWarning: le package 'oceanis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : shiny\n\n\nWarning: le package 'shiny' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : shinyBS\n\n\nWarning: le package 'shinyBS' a été compilé avec la version R 4.2.3\n\nlibrary(\"stringr\")\n\nWarning: le package 'stringr' a été compilé avec la version R 4.2.3\n\n\nDans un premier temps nous allons travailler avc mapview. Mapview est une bibliothèque R qui permet d’afficher des données géospatiales interactives et de les explorer facilement. Elle offre une interface graphique conviviale qui permet de zoomer, de déplacer et de sélectionner des données géospatiales à l’aide de la souris.\nNous décidons de travailler sur Paris tout au long de ce tuto.\n\nOn télécharge les données des arrondissements de Paris à partir du site opendata.paris.fr et stocke les données dans l’objet arrondissements sous forme d’un objet de type sf.\n\n\n# Télécharger les données des arrondissements de Paris\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\n\nOn convertit l’objet en un dataframe pour pouvoir travailler dessus.\n\n\n# Convertir l'objet sf en un data.frame\narrondissements_df &lt;- st_drop_geometry(arrondissements)\n\n\nOn supprime les colonnes qui ne sont pas nécessaires pour la représentation spatiale.\n\n\n# Supprimer les colonnes qui ne sont pas nécessaires pour la représentation spatiale\ncols_to_remove &lt;- c(\"datasetid\", \"recordid\", \"fields\", \"geometry_name\", \"type\")\narrondissements_df &lt;- arrondissements_df[, !(names(arrondissements_df) %in% cols_to_remove)]\n\n\nOn convertit les colonnes de type list en caractère et la liste en dataframe/\n\n\n# Convertir les colonnes de type list en caractère\narrondissements_df &lt;- lapply(arrondissements_df, function(x) if (is.list(x)) as.character(x) else x)\n\n# Convertir la liste en data.frame\narrondissements_df &lt;- as.data.frame(arrondissements_df)\n\n\nOn crée un exemple de données df composé de deux colonnes : ‘id’ et ‘coordinates’, où ‘coordinates’ contient les coordonnées de chaque arrondissement.\n\nMes données sont sous la forme d’un vecteur c(a,b). Pour travailler plus simplement je travaille sur la colonne avec le vecteur en question pour créer deux colonnes latitude et longitude.\n\n# Exemple de données\ndf &lt;- data.frame(id = c(1, 2), coordinates = arrondissements_df$geom_x_y)\n\n\n# Diviser la chaîne de caractères à la virgule et extraire la deuxième partie\ncoord_vec &lt;- as.data.frame(strsplit(df$coordinates, \",\"))\ncoord_vec[1,] &lt;- gsub(\"c\", \"\", coord_vec[1,]) # je supprime le c\ncoord_vec[1,] &lt;- gsub('\\\\(', \"\", coord_vec[1,]) # je supprime la parenthèse\ncoord_vec[2,] &lt;- gsub('\\\\)', \"\", coord_vec[2,])\n\n\ncoord_vec[1,]&lt;- as.numeric(coord_vec[1,])\n\ncoord_vec[2,]&lt;- as.numeric(coord_vec[2,])\n\n\ncoord_vec_tranposee&lt;-t(coord_vec)\n\n# Afficher le résultat\narrondissements_df$lon&lt;-coord_vec_tranposee[,1]\narrondissements_df$lat&lt;-coord_vec_tranposee[,2]\n\n\n# Afficher les premières lignes du data.frame\narrondissements_sf &lt;- st_as_sf(arrondissements_df, coords = c(\"lat\",\"lon\"), crs=4326)\n# Retour au format sf pour appliquer la fonction mapview()\nmapview(arrondissements_sf, zcol = c(\"c_ar\",\"l_aroff\"))\n\n\n\n\n\n\nNous allons travailler avec le package Oceanis. Le package oceanis permet de réaliser des cartes d’analyses.\n\nlibrary(oceanis)\n\n\nCréation d’un groupe : Création d’un vecteur d’identifiants de maille pour chaque arrondissement, un vecteur de code de groupe et un vecteur de noms officiels d’arrondissements.\n\n\n# création d'un Groupe\n\n# Créer un vecteur d'identifiants de maille pour chaque arrondissement\nc_ar &lt;- c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\")\n# Créer un groupe \ncode_groupe &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)\n\n# Créer un vecteur de noms officiels d'arrondissements avec les noms que vous avez fournis\nl_aroff &lt;- c(\"Louvre\", \"Bourse\", \"Temple\", \"Hôtel-de-Ville\", \"Panthéon\", \"Luxembourg\", \"Palais-Bourbon\", \"Élysée\", \"Opéra\", \"Enclos-St-Laurent\", \"Popincourt\", \"Reuilly\", \"Gobelins\", \"Observatoire\", \"Vaugirard\", \"Passy\", \"Batignolles-Monceau\", \"Buttes-Montmartre\", \"Buttes-Chaumont\", \"Ménilmontant\")\n\n# Créer un data.frame contenant les trois vecteurs\narrondissements_paris &lt;- data.frame(c_ar, code_groupe, l_aroff)\n\n# Afficher le tableau de données\nprint(arrondissements_paris)\n\n\nCréation d’un zonage à façon des arrondissements de Paris en utilisant la fonction zonage_a_facon() qui prend en entrée les données des arrondissements, le data.frame contenant les identifiants de maille et les codes de groupe, ainsi que les noms officiels d’arrondissements.\n\n\n# Créer le zonage à façon\nze13 &lt;- zonage_a_facon(arrondissements, arrondissements_paris, \"c_ar\", \"code_groupe\", \"l_aroff\")\n\n\nAffichage de la carte avec les identifiants de maille colorés selon leur groupe. Ajout du nom de chaque arrondissement à son centre en créant un vecteur de noms d’arrondissements correspondant aux identifiants de chaque arrondissement. Affichage de la carte avec les noms d’arrondissements. Coloration d’un arrondissement spécifique (le 15e arrondissement) en rouge et les autres en gris, en sélectionnant le polygone correspondant à l’arrondissement 15 et en utilisant la fonction ifelse() pour colorier l’arrondissement 15 en rouge et les autres en gris. Affichage de la carte avec les noms d’arrondissements et l’arrondissement 15 coloré en rouge.\n\n\n# Créer un vecteur de noms d'arrondissements correspondant aux identifiants de chaque arrondissement\nnom_arondissement &lt;- arrondissements_paris$l_aroff[match(ze13$CODE_TERR, arrondissements_paris$code_groupe)]\n\n# Ajouter le nom de chaque arrondissement à son centre\nze13$nom_arondissement &lt;- nom_arondissement\n\n# Afficher la carte avec les noms d'arrondissements\n\n# On va colorier l'arrondissment Vaugirard\n\n# Sélectionner le polygone correspondant à l'arrondissement 15\narrondissement_15 &lt;- ze13[ze13$CODE_TERR == 15, ]\n\n# Afficher la carte avec l'arrondissement 5 en rouge et les autres en gris\nplot(sf::st_geometry(ze13), col = ifelse(ze13$CODE_TERR == 15, \"red\", \"grey\"), border = \"black\", lwd = 1.5)\ntext(sf::st_coordinates(st_centroid(ze13)), labels = ze13$nom_arondissement, cex = 0.8, col = \"black\")\n\nWarning: st_centroid assumes attributes are constant over geometries\n\ntitle(\"Zonage à façon des arrondissements de Paris\")\n\n\n\n\nOn va maintenant essayer de coloriser les arrondissement en fonction de la population. Dans un premier temps on créer une variable population\n\nze13$pop&lt;-c(100196, 95487, 146699, 136591, 58850, 140849, 142462, 118238, 166860, 163445, 139992, 102163, 183399, 169214, 165494, 149500, 144657, 104287, 142005, 100831)\n\nJe fais le choix d’avoir un dégradé de couleur bleu, voici la commande pour l’obtenir:\n\nlibrary(grDevices)\nmycolors &lt;- colorRampPalette(c(\"lightblue\", \"darkblue\"))(20)\n\nPuis je réalise mon plot\n\n# On construit le graphique\nplot(sf::st_geometry(ze13), col = mycolors[cut(ze13$pop, breaks = ze13$pop)], border = \"black\", lwd = 1.5)\n\ntext(sf::st_coordinates(st_centroid(ze13)), labels = ze13$nom_arondissement, cex = 0.8, col = \"white\")\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n# Ajouter une légende\nlegend(\"topright\", \n       title = \"Population\", \n       legend = ze13$nom_arondissement, \n       fill = mycolors[cut(ze13$pop, breaks = ze13$pop)], \n       border = \"black\",\n       box.lwd = 1,\n       cex=0.5) #réduire la taille de la légende\ntitle(\"Zonage à façon des arrondissements de Paris\")\n\n\n\n\nPour les plus aguerries.es on peut utiliser ggplot\n\nlibrary(viridis)\n\nWarning: le package 'viridis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : viridisLite\n\n\nWarning: le package 'viridisLite' a été compilé avec la version R 4.2.3\n\nlibrary(grDevices)\nlibrary(ggplot2)\n\nWarning: le package 'ggplot2' a été compilé avec la version R 4.2.3\n\n# Convertir l'objet sf en un objet ggplot2\nggplot_data &lt;- ggplot() + \n  geom_sf(data = ze13, aes(fill = pop, color = NULL)) + \n  labs(title = \"Zonage à façon des arrondissements de Paris\") + \n  scale_color_viridis(option = \"D\")"
  },
  {
    "objectID": "R/Package_purrr/package_purrr.html",
    "href": "R/Package_purrr/package_purrr.html",
    "title": "Comment faire de la programmation fonctionelle avec Purrr",
    "section": "",
    "text": "purrr est un package dédié à la programmation fonctionnelle. Ses fonctions principales sont les fonctions map() (map(), map_chr(), map_dbl(), map_dfr(), etc…), elles permettent d’appliquer une même fonction (ou une même série de fonctions) à chaque élément d’un ensemble (les colonnes d’un data frame, ou les éléments d’une list par exemple). En gros, ces fonctions map() permettent de remplacer les boucles for() avantageusement en termes de nombre de lignes de code et de temps de calcul (parce que ces fonctions reposent sur la récursivité).\n\nlibrary(purrr) \n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nA titre d’exemple on va essayer de supposer que nous avons une liste de vecteurs numériques et que nous allons appliquer une fonction à chaque vecteur pour en extraire la valeur maximale. Sans le package purr il est nécessaire d’utiliser une boucle for:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Initialiser un vecteur vide pour stocker les résultats\nmax_vals &lt;- numeric(length(my_list))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nfor (i in seq_along(my_list)) {\n  max_vals[i] &lt;- max(my_list[[i]])\n}\n# Afficher les résultats\nmax_vals\n\n[1] 3 6 9\n\n\nAvec le package purrr:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nmax_vals &lt;- map(my_list, max)\n\n# Afficher les résultats\nmax_vals\n\non remarque qu’on gagne quand même pas mal de temps d’écriture en utilisant le package purrr, ce qui peut vraiment servir quand on a de pas mal de ligne de code.\n\n\nPour en apprendre plus sur le package purr :\nhttps://delladata.fr/liste-de-ressources-pour-le-package-purrr/"
  },
  {
    "objectID": "R/Package_rio/Rio_package.html",
    "href": "R/Package_rio/Rio_package.html",
    "title": "Package Rio",
    "section": "",
    "text": "L’import de données est la base de tout programme informatique portant sur le traitement de données. Le package “rio” est une collection de fonctions pour importer et exporter des données dans différents formats avec R. Il permet d’importer facilement des fichiers de données à partir de diverses sources, notamment des fichiers plats, des bases de données, des fichiers SAS, SPSS et Stata, ainsi que des fichiers Excel et RData. Il faut au préalable installer le package avec la commande suivante: ” install.packages(“rio”)“.\n\n# ---- Librairie ---- \n\nlibrary(rio)\n\nWarning: le package 'rio' a été compilé avec la version R 4.2.3\n\ninstall_formats()\n\n[1] TRUE\n\n# --- import de données --- \n\n#Pour des données au format xlsx\n\ndata_xslx&lt;-import(\"election_leg.xlsx\") \n\n\n#Pour des données au format SAS (ou autre), c'est la même chose.\ndata_sas&lt;-import(\"chemin_d_acces.sas7bdat\")\n\nPour exporter une base de données dans un fichier, il est recommandé d’utiliser la méthode “export” en utilisant le dataframe que vous voulez exporter, ici “data_sas” (comme illustré ci-dessous), et en spécifiant le chemin où vous souhaitez le sauvegarder. Cette méthode est généralement utilisée lorsque vous apportez des modifications directes à votre dataframe et que vous souhaitez enregistrer les changements quelque part.\n\n# --- export de données ---\n\nchemin_acces&lt;-export(data_sas,\"election_leg.xlsx\")\n\nPour en apprendre plus sur le package rio https://rdocumentation.org/packages/rio/versions/0.5.29\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "R/Git/git.html",
    "href": "R/Git/git.html",
    "title": "Comment utiliser GitHub",
    "section": "",
    "text": "GitHub est une plateforme de développement collaboratif de logiciels qui facilite le partage, la gestion et la collaboration sur des projets de développement de logiciels.\n\n1. Créer un nouveau dépot\nRepository ou Projet ?\nun repository est l’endroit où est stocké le code source d’un projet, tandis qu’un projet est une fonctionnalité pour organiser les tâches, les problèmes et les notes liés à ce projet.\nNous allons créer un repository qui permmettra de stocker toutes les fiches R déjà faites. Il faut donc cliquer sur le petit plus dans la barre de navigation et selectionner “new repository”.\n\n\n\n2. Le repository\nPour créer le nouveau repository il faudra choisir un nom (repository name) Une description, une visibilité (publique ou privé).\nJe fais le choix d’ajouter directement le fichier README.md à mon repository. Le fichier README.md est un fichier texte présent à la racine d’un dépôt GitHub qui décrit le projet et fournit des informations importantes aux utilisateurs et aux contributeurs du projet. Le fichier README est généralement écrit en format Markdown, qui permet de formater le texte avec des titres, des listes, des liens, des images, etc.\n\nVoici ce que vous obtiendrez par la suite\n\n\n\n3. Un premier ajout de fichier\nIl faut a présent se placer dans votre terminal (VScode ou autre) et exectuer les commandes suivantes:\ngit init\nCette commande initialise un nouveau dépôt Git dans le répertoire courant. Elle crée un sous-répertoire nommé .git qui contient tous les fichiers nécessaires pour gérer le dépôt Git.\ngit add READ.md\nCette commande initialise un nouveau dépôt Git dans le répertoire courant. Elle crée un sous-répertoire nommé .git qui contient tous les fichiers nécessaires pour gérer le dépôt Git.\ngit commit -m “first commit”\nCette commande initialise un nouveau dépôt Git dans le répertoire courant. Elle crée un sous-répertoire nommé .git qui contient tous les fichiers nécessaires pour gérer le dépôt Git.\ngit branch -M main\nCette commande renomme la branche par défaut de “master” à “main”.\ngit remote add origin “https://github.com/nom_utilisateur/test_git.git”\nCette commande ajoute un nouveau référentiel Git distant appelé “origin”. Le nom “origin” est généralement utilisé pour le référentiel distant principal. L’URL est celle de votre dépôt GitHub et s’obtient en cliquant sur le petit bouton bleu code\ngit push -u origin main\nCette commande envoie les modifications du dépôt local vers le dépôt distant sur GitHub. L’option “-u” permet d’associer la branche locale “main” avec la branche distante “main” sur le référentiel “origin”. Cette étape ne sera nécessaire que pour le premier push, les pushs suivants, la commande sera simplement git push.\n\n\n4. Pour des ajouts réguliers\ngit add lien_du_fichier_a_ajouter\ngit commit -m “ajout du jour”\ngit push origin main\n\n\n5. Comment fusionner deux branches ?\nIci, on cherche à fusionner la branche main et master.\ngit checkout main\nCette commande change de branche pour la branche “main”. Cette commande doit être exécutée avant de fusionner la branche “master” pour s’assurer que les modifications sont apportées à la bonne branche.\ngit merge master\nCette commande fusionne la branche “master” avec la branche “main”. Si Git détecte un conflit entre les deux branches, il vous informera que la fusion ne peut pas être effectuée automatiquement et qu’il est nécessaire de résoudre le conflit manuellement.\ngit add lien_du_fichier_a_ajouter\ngit commit -m “resolution de conflit”\ngit push origin main"
  }
]