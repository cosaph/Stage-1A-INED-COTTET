[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\nCe site a été créé dans le cadre de mon stage de première année à l’INED. Mon objectif est de rédiger une série d’articles sur l’utilisation de R pour soutenir les chercheurs.es dans leurs travaux.\nR est un langage de programmation et un environnement statistique largement utilisé dans le domaine de la recherche. Il est particulièrement populaire dans les domaines des statistiques, de la bioinformatique, de l’économétrie, de la finance et de l’analyse des données en général."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Cartographie.html",
    "href": "Cartographie.html",
    "title": "Comment réaliser une carte sur R ? Avec mapsf",
    "section": "",
    "text": "Nous allons réaliser des cartes avec R à l’aide du packages install.packages(“mapsf”).\n\nlibrary(mapsf)\n\nWarning: le package 'mapsf' a été compilé avec la version R 4.2.3\n\nlibrary(sf)\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE"
  },
  {
    "objectID": "Package_mapsf/map_sf.html",
    "href": "Package_mapsf/map_sf.html",
    "title": "Mapsf",
    "section": "",
    "text": "Nous allons réaliser des cartes avec R à l’aide du packages install.packages(“mapsf”).\n\nlibrary(mapsf)\n\nWarning: le package 'mapsf' a été compilé avec la version R 4.2.3\n\nlibrary(sf)\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\n\nNous allons réaliser une carte des arrondissments de Paris. J’ai récupérer les données sur le site de Paris Data : https://opendata.paris.fr/pages/catalogue/?disjunctive.theme&disjunctive.publisher\nJe réalise un fond de carte.\n\n# ----- Import des données -----\n\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr' \n  using driver `GeoJSON'\nSimple feature collection with 20 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2.224078 ymin: 48.81558 xmax: 2.469761 ymax: 48.90216\nGeodetic CRS:  WGS 84\n\ncours_deau&lt;-st_read(dsn=\"https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin' \n  using driver `GeoJSON'\nSimple feature collection with 58 features and 25 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.224081 ymin: 48.81924 xmax: 2.450555 ymax: 48.90207\nGeodetic CRS:  WGS 84\n\n\n\n#Dans un premier temps je réalise mon fond de carte avec les arrondissments de Paris \nmf_map(x = arrondissements, border = \"black\") \n\n#Je rajoute les cours d'eau sur mon fond de carte avec l'argument \"add=TRUE\"\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\n\n\n\n\n\n# d'un point de vue esthétique je choisis d'appliquer un fond noir à mes cartes\nmf_theme(\"darkula\")\n\nLes différents type de cartes\n\nLes cartes à symboles proportionels\nLes cartes à symboles proportionnels sont une méthode de représentation graphique utilisée pour visualiser les variables de stocks, ce qui correspond à des variables quantitatives absolues pour lesquelles la somme et la moyenne ont une signification.\n\narrondissements$pop &lt;- c(1012687, 903036, 1369857, 1491027, 1672009, 1506475, 1637163, 1603380, 1637542, 1059282, 1494945, 1436205, 1705774, 1425805, 236769, 1668605, 1674568, 1539668, 1421827, 1829526) #INSEE,2021\nmf_map(x = arrondissements, border = \"black\")\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\nmf_map(\n  x = arrondissements,\n  var = \"pop\",\n  type = \"prop\",\n  leg_title = \"Population totale\\12 271 794\",\n  col=\"#F39487\",\n  add= TRUE\n)\n\nmf_title(\"Distribution de la population dans Paris\")\n\n\n\n\nLes cartes choroplètes\nLes cartes choroplèthes sont une méthode courante de représentation graphique utilisée pour visualiser les variables de ratios, qui correspondent à des variables quantitatives relatives pour lesquelles la moyenne a un sens, mais la somme n’a pas de sens.\n\n#création de la variable densite \narrondissements$DENS &lt;- 1e6 * arrondissements$pop / as.numeric(st_area(arrondissements))\nmf_map(\n  x = arrondissements,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  pal = \"Reds\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0\n)\n\nmf_title(\"Distribution de la population dans Paris (INSEE,2021)\")\n\n\n\n\nOn peut aussi représenter ces variables sous d’autres forme:\n\narr_c&lt;-st_centroid(arrondissements)\n\nWarning: st_centroid assumes attributes are constant over geometries\n\nmf_map(x = arrondissements, border = \"black\")\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\nmf_map(\n  x = arr_c,\n  var = \"DENS\",\n  type = \"choro\",\n  breaks = \"quantile\",\n  pal = \"Inferno\",\n  pch = 24,\n  cex = 2,\n  border = \"#F29094\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0,\n  add= TRUE\n)\n\n\n\n\nEt si on regroupait deux arrondissemtns ?\nLe code ci-dessous montre la fusion du 15e et 16e arrondissement. L’idée globale du code c’est de fusionner les deux polygones (celui du 15e et du 16e). Ensuite, on recrée toute la ligne de notre tableau de donnée pour pouvoir la fusionner avec celui-ci.\n\n# ---- Fusionner deux polygones ---- #\n\n# Sélectionner les deux polygones que vous souhaitez fusionner\npoly1 &lt;- arrondissements[arrondissements$l_aroff == \"Passy\", ] # sélectionne le polygone avec le nom \"Passy\"\npoly2 &lt;- arrondissements[arrondissements$l_aroff == \"Vaugirard\", ] # sélectionne le polygone avec le nom \"Vaugirard\"\n\n# Fusionner les polygones\nnew_poly &lt;- st_union(poly1, poly2) # fusionne les deux polygones sélectionnés en un seul polygone\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\n# Ajouter la surface, la population, le périmètre et les coordonnées géographiques des deux polygones \n\n#l'idée c'est de recréer une nouvelle ligne pour notre nouveau polygone pour qu'on puisse le reinsérer dans notre tableau. \n\nnew_poly$surface &lt;- new_poly$surface + new_poly$surface.1 # ajouter la surface des deux polygones\nnew_poly$n_sq_co &lt;- new_poly$n_sq_co + new_poly$n_sq_co.1 # ajouter la population des deux polygones\nnew_poly$perimetre &lt;- new_poly$perimetre + new_poly$perimetre.1 # ajouter le périmètre des deux polygones\nnew_poly$n_sq_ar &lt;- new_poly$n_sq_ar + new_poly$n_sq_ar.1 # ajouter les coordonnées géographiques des deux polygones\n\n# Modifier les informations de localisation\nnew_poly$l_aroff &lt;- \"un nouvel arrondissement\" # changer le nom de l'arrondissement\nnew_poly$l_ar &lt;- \"xxème Ardt\" # changer le numéro de l'arrondissement\nnew_poly$c_ar &lt;- \"xx\" # changer le code de l'arrondissement\nnew_poly$c_arinsee &lt;- \"75xxxx\" # changer le code INSEE de la commune\n\n# Sélectionner certaines colonnes pour créer un nouvel objet de données\narrondissements_test &lt;- subset(new_poly, select = c(c_ar, l_aroff, surface, l_ar, n_sq_co, c_arinsee, n_sq_ar, perimetre, geom_x_y))\n# à noter qu'il est très important de mettre les éléments dans le même ordre que celui du tableau\n\n# Remplacer les informations de l'arrondissement \"Passy\" dans l'objet \"arrondissements\" par les nouvelles informations\narrondissements[arrondissements$l_aroff == \"Passy\", ] &lt;- arrondissements_test\n\n# Afficher la carte de l'objet \"arrondissements\" avec les frontières en noir\nmf_map(x = arrondissements, border = \"black\")\n\n\n\n\nPour la rédaction de cet article je me suis grandement inspirée du travail de Timothée Giraud.\nhttps://rcarto.github.io/ined2022/07_mise_en_page.html"
  },
  {
    "objectID": "Package_mapsf/R_cartographie.html",
    "href": "Package_mapsf/R_cartographie.html",
    "title": "Mapview et Oceanis",
    "section": "",
    "text": "Nous allons vous présenter trois packages un peu différent pour obtenir des cartes : sf , mapview et oceanis. Il faut donc au préalable installer ces deux packages. install.packages(“sf”) install.packages(“mapview”) install.packages(“oceanis”) install.packages(“stringr”) #qui sera utiliser pour traiter les données.\n\nlibrary(\"sf\")\n\nWarning: le package 'sf' a été compilé avec la version R 4.2.3\n\n\nLinking to GEOS 3.9.3, GDAL 3.5.2, PROJ 8.2.1; sf_use_s2() is TRUE\n\nlibrary(\"mapview\")\n\nWarning: le package 'mapview' a été compilé avec la version R 4.2.3\n\n\nThe legacy packages maptools, rgdal, and rgeos, underpinning this package\nwill retire shortly. Please refer to R-spatial evolution reports on\nhttps://r-spatial.org/r/2023/05/15/evolution4.html for details.\nThis package is now running under evolution status 0 \n\nlibrary(\"oceanis\")\n\nWarning: le package 'oceanis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : shiny\n\n\nWarning: le package 'shiny' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : shinyBS\n\n\nWarning: le package 'shinyBS' a été compilé avec la version R 4.2.3\n\nlibrary(\"stringr\")\n\nWarning: le package 'stringr' a été compilé avec la version R 4.2.3\n\n\nDans un premier temps nous allons travailler avc mapview. Mapview est une bibliothèque R qui permet d’afficher des données géospatiales interactives et de les explorer facilement. Elle offre une interface graphique conviviale qui permet de zoomer, de déplacer et de sélectionner des données géospatiales à l’aide de la souris.\nNous décidons de travailler sur Paris tout au long de ce tuto.\n\nOn télécharge les données des arrondissements de Paris à partir du site opendata.paris.fr et stocke les données dans l’objet arrondissements sous forme d’un objet de type sf.\n\n\n# Télécharger les données des arrondissements de Paris\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\n\nOn convertit l’objet en un dataframe pour pouvoir travailler dessus.\n\n\n# Convertir l'objet sf en un data.frame\narrondissements_df &lt;- st_drop_geometry(arrondissements)\n\n\nOn supprime les colonnes qui ne sont pas nécessaires pour la représentation spatiale.\n\n\n# Supprimer les colonnes qui ne sont pas nécessaires pour la représentation spatiale\ncols_to_remove &lt;- c(\"datasetid\", \"recordid\", \"fields\", \"geometry_name\", \"type\")\narrondissements_df &lt;- arrondissements_df[, !(names(arrondissements_df) %in% cols_to_remove)]\n\n\nOn convertit les colonnes de type list en caractère et la liste en dataframe/\n\n\n# Convertir les colonnes de type list en caractère\narrondissements_df &lt;- lapply(arrondissements_df, function(x) if (is.list(x)) as.character(x) else x)\n\n# Convertir la liste en data.frame\narrondissements_df &lt;- as.data.frame(arrondissements_df)\n\n\nOn crée un exemple de données df composé de deux colonnes : ‘id’ et ‘coordinates’, où ‘coordinates’ contient les coordonnées de chaque arrondissement.\n\nMes données sont sous la forme d’un vecteur c(a,b). Pour travailler plus simplement je travaille sur la colonne avec le vecteur en question pour créer deux colonnes latitude et longitude.\n\n# Exemple de données\ndf &lt;- data.frame(id = c(1, 2), coordinates = arrondissements_df$geom_x_y)\n\n\n# Diviser la chaîne de caractères à la virgule et extraire la deuxième partie\ncoord_vec &lt;- as.data.frame(strsplit(df$coordinates, \",\"))\ncoord_vec[1,] &lt;- gsub(\"c\", \"\", coord_vec[1,]) # je supprime le c\ncoord_vec[1,] &lt;- gsub('\\\\(', \"\", coord_vec[1,]) # je supprime la parenthèse\ncoord_vec[2,] &lt;- gsub('\\\\)', \"\", coord_vec[2,])\n\n\ncoord_vec[1,]&lt;- as.numeric(coord_vec[1,])\n\ncoord_vec[2,]&lt;- as.numeric(coord_vec[2,])\n\n\ncoord_vec_tranposee&lt;-t(coord_vec)\n\n# Afficher le résultat\narrondissements_df$lon&lt;-coord_vec_tranposee[,1]\narrondissements_df$lat&lt;-coord_vec_tranposee[,2]\n\n\n# Afficher les premières lignes du data.frame\narrondissements_sf &lt;- st_as_sf(arrondissements_df, coords = c(\"lat\",\"lon\"), crs=4326)\n# Retour au format sf pour appliquer la fonction mapview()\nmapview(arrondissements_sf, zcol = c(\"c_ar\",\"l_aroff\"))\n\n\n\n\n\n\nNous allons travailler avec le package Oceanis. Le package oceanis permet de réaliser des cartes d’analyses.\n\nlibrary(oceanis)\n\n\nCréation d’un groupe : Création d’un vecteur d’identifiants de maille pour chaque arrondissement, un vecteur de code de groupe et un vecteur de noms officiels d’arrondissements.\n\n\n# création d'un Groupe\n\n# Créer un vecteur d'identifiants de maille pour chaque arrondissement\nc_ar &lt;- c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\")\n# Créer un groupe \ncode_groupe &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)\n\n# Créer un vecteur de noms officiels d'arrondissements avec les noms que vous avez fournis\nl_aroff &lt;- c(\"Louvre\", \"Bourse\", \"Temple\", \"Hôtel-de-Ville\", \"Panthéon\", \"Luxembourg\", \"Palais-Bourbon\", \"Élysée\", \"Opéra\", \"Enclos-St-Laurent\", \"Popincourt\", \"Reuilly\", \"Gobelins\", \"Observatoire\", \"Vaugirard\", \"Passy\", \"Batignolles-Monceau\", \"Buttes-Montmartre\", \"Buttes-Chaumont\", \"Ménilmontant\")\n\n# Créer un data.frame contenant les trois vecteurs\narrondissements_paris &lt;- data.frame(c_ar, code_groupe, l_aroff)\n\n# Afficher le tableau de données\nprint(arrondissements_paris)\n\n\nCréation d’un zonage à façon des arrondissements de Paris en utilisant la fonction zonage_a_facon() qui prend en entrée les données des arrondissements, le data.frame contenant les identifiants de maille et les codes de groupe, ainsi que les noms officiels d’arrondissements.\n\n\n# Créer le zonage à façon\nze13 &lt;- zonage_a_facon(arrondissements, arrondissements_paris, \"c_ar\", \"code_groupe\", \"l_aroff\")\n\n\nAffichage de la carte avec les identifiants de maille colorés selon leur groupe. Ajout du nom de chaque arrondissement à son centre en créant un vecteur de noms d’arrondissements correspondant aux identifiants de chaque arrondissement. Affichage de la carte avec les noms d’arrondissements. Coloration d’un arrondissement spécifique (le 15e arrondissement) en rouge et les autres en gris, en sélectionnant le polygone correspondant à l’arrondissement 15 et en utilisant la fonction ifelse() pour colorier l’arrondissement 15 en rouge et les autres en gris. Affichage de la carte avec les noms d’arrondissements et l’arrondissement 15 coloré en rouge.\n\n\n# Créer un vecteur de noms d'arrondissements correspondant aux identifiants de chaque arrondissement\nnom_arondissement &lt;- arrondissements_paris$l_aroff[match(ze13$CODE_TERR, arrondissements_paris$code_groupe)]\n\n# Ajouter le nom de chaque arrondissement à son centre\nze13$nom_arondissement &lt;- nom_arondissement\n\n# Afficher la carte avec les noms d'arrondissements\n\n# On va colorier l'arrondissment Vaugirard\n\n# Sélectionner le polygone correspondant à l'arrondissement 15\narrondissement_15 &lt;- ze13[ze13$CODE_TERR == 15, ]\n\n# Afficher la carte avec l'arrondissement 5 en rouge et les autres en gris\nplot(sf::st_geometry(ze13), col = ifelse(ze13$CODE_TERR == 15, \"red\", \"grey\"), border = \"black\", lwd = 1.5)\ntext(sf::st_coordinates(st_centroid(ze13)), labels = ze13$nom_arondissement, cex = 0.8, col = \"black\")\n\nWarning: st_centroid assumes attributes are constant over geometries\n\ntitle(\"Zonage à façon des arrondissements de Paris\")\n\n\n\n\nOn va maintenant essayer de coloriser les arrondissement en fonction de la population. Dans un premier temps on créer une variable population\n\nze13$pop&lt;-c(100196, 95487, 146699, 136591, 58850, 140849, 142462, 118238, 166860, 163445, 139992, 102163, 183399, 169214, 165494, 149500, 144657, 104287, 142005, 100831)\n\nJe fais le choix d’avoir un dégradé de couleur bleu, voici la commande pour l’obtenir:\n\nlibrary(grDevices)\nmycolors &lt;- colorRampPalette(c(\"lightblue\", \"darkblue\"))(20)\n\nPuis je réalise mon plot\n\n# On construit le graphique\nplot(sf::st_geometry(ze13), col = mycolors[cut(ze13$pop, breaks = ze13$pop)], border = \"black\", lwd = 1.5)\n\ntext(sf::st_coordinates(st_centroid(ze13)), labels = ze13$nom_arondissement, cex = 0.8, col = \"white\")\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n# Ajouter une légende\nlegend(\"topright\", \n       title = \"Population\", \n       legend = ze13$nom_arondissement, \n       fill = mycolors[cut(ze13$pop, breaks = ze13$pop)], \n       border = \"black\",\n       box.lwd = 1,\n       cex=0.5) #réduire la taille de la légende\ntitle(\"Zonage à façon des arrondissements de Paris\")\n\n\n\n\nPour les plus aguerries.es on peut utiliser ggplot\n\nlibrary(viridis)\n\nWarning: le package 'viridis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : viridisLite\n\n\nWarning: le package 'viridisLite' a été compilé avec la version R 4.2.3\n\nlibrary(grDevices)\nlibrary(ggplot2)\n\nWarning: le package 'ggplot2' a été compilé avec la version R 4.2.3\n\n# Convertir l'objet sf en un objet ggplot2\nggplot_data &lt;- ggplot() + \n  geom_sf(data = ze13, aes(fill = pop, color = NULL)) + \n  labs(title = \"Zonage à façon des arrondissements de Paris\") + \n  scale_color_viridis(option = \"D\")"
  },
  {
    "objectID": "Nuage_de_mot/nuage_de_mot.html",
    "href": "Nuage_de_mot/nuage_de_mot.html",
    "title": "Nuage de mot (Tm)",
    "section": "",
    "text": "Comme dans tout bon code R il est nécessaire au début d’installer (une fois sur un ordinateur): (dans le terminal de commande ) install.packages(“tm”) # pour le text mining install.packages(“SnowballC”) # pour le text stemming install.packages(“wordcloud”) # générateur de word-cloud install.packages(“RColorBrewer”) # Palettes de couleurs les packages recquis pour le code et de charger (à chaque fois ) les librairies requisent pour le code.\n\n# ---- library ----\nlibrary(\"tm\") # pour le text mining\n\nWarning: le package 'tm' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : NLP\n\nlibrary(\"SnowballC\") # pour le text stemming\n\nWarning: le package 'SnowballC' a été compilé avec la version R 4.2.3\n\nlibrary(\"wordcloud\") # générateur de word-cloud \n\nWarning: le package 'wordcloud' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : RColorBrewer\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\nLe text-mining (ou fouille de texte) est une technique d’analyse de données qui consiste à extraire des informations significatives à partir de données textuelles non structurées telles que des documents, des e-mails, des pages web, des tweets, etc.\nLe stemming est une technique de traitement automatique du langage naturel (TALN) qui consiste à réduire les mots à leur forme racine ou à leur base lexicale, en éliminant les suffixes ou les terminaisons des mots. Par exemple, le stemming pourrait transformer les mots “manger”, “mangeais” et “mangé” en leur forme racine “mang”.\nJ’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# Lire le fichier texte\nfilePath &lt;- \"genre.txt\"\ntext &lt;- readLines(filePath)\n\nWarning in readLines(filePath): ligne finale incomplète trouvée dans\n'genre.txt'\n\n# Charger les données comme un corpus\ndocs &lt;- Corpus(VectorSource(text))\n\nPar la suite, il faut transformer un peu le texte pour ne gardez que l’essentiel, le coeur du sujet. Il faut donc supprimer les “stopword” (le,la,une,des,…).\n\n# ---- Transofrmation du texte ----\n\ntoSpace &lt;- content_transformer(function (x , pattern ) gsub(pattern, \" \", x)) \n\n# Convertir le texte en minuscule\ndocs &lt;- tm_map(docs, content_transformer(tolower)) \n\nWarning in tm_map.SimpleCorpus(docs, content_transformer(tolower)):\ntransformation drops documents\n\n# Supprimer les mots vides anglais\ndocs &lt;- tm_map(docs, removeWords, stopwords(\"fr\"))\n\nWarning in tm_map.SimpleCorpus(docs, removeWords, stopwords(\"fr\")):\ntransformation drops documents\n\n# Supprimer votre propre liste de mots non désirés\ndocs &lt;- tm_map(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")) \n\nWarning in tm_map.SimpleCorpus(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")):\ntransformation drops documents\n\n# Supprimer les ponctuations\ndocs &lt;- tm_map(docs, removePunctuation)\n\nWarning in tm_map.SimpleCorpus(docs, removePunctuation): transformation drops\ndocuments\n\n# Supprimer les espaces vides supplémentaires\ndocs &lt;- tm_map(docs, stripWhitespace)\n\nWarning in tm_map.SimpleCorpus(docs, stripWhitespace): transformation drops\ndocuments\n\ninspect(docs) #inspecter le document\n\nS’il on veut supprimer des nombres, on utilise la syntaxe : “docs &lt;- tm_map(docs, removeNumbers)”\nOn réalise ensuite une table de fréquence d’apparition des mots\n::: {.cell}\n# table de fréquence de mot (voir table d'occurence)\ndtm &lt;- TermDocumentMatrix(docs)\nm &lt;- as.matrix(dtm)\nv &lt;- sort(rowSums(m),decreasing=TRUE)\nd &lt;- data.frame(word = names(v),freq=v)\nhead(d, 12) # affiche les 12 mots avec les plus grosses fréquences. \n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=brewer.pal(8, \"Paired\")) #réalisation du nuage de mots.\n::: {.cell-output-display}  :::\n# On pourrait faire quelque chose de beaucoup plus neutre en terme de couleur avec la commande :\n\n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=\"black\")\n::: {.cell-output-display}  ::: :::\nC’est quoi le set.seed(1234) ? Lorsque vous utilisez une graine aléatoire (le set.seed(1234)), cela garantit que les résultats de votre analyse seront les mêmes à chaque fois que vous exécutez le code. Cela est particulièrement important lorsque vous travaillez avec des fonctions qui impliquent une certaine forme d’aléatoire, comme la génération de nuages de mots.\nAinsi, si vous utilisez la même graine aléatoire (par exemple, 1234) dans votre code chaque fois que vous exécutez l’analyse, vous obtiendrez toujours les mêmes résultats, ce qui facilite la reproductibilité de votre analyse. Sans fixer la graine aléatoire, la génération du nuage de mots peut varier à chaque exécution, car les fonctions qui génèrent le nuage de mots utilisent généralement des algorithmes aléatoires pour placer les mots dans l’espace et choisir les couleurs. Cela signifie que chaque fois que vous exécutez le code, vous obtiendrez un nuage de mots différent, même si les données d’entrée sont les mêmes.\nPour en apprendre plus sur la constrcution des images de mots : http://www.sthda.com/french/wiki/text-mining-et-nuage-de-mots-avec-le-logiciel-r-5-etapes-simples-a-savoir"
  },
  {
    "objectID": "Nuage_de_mot/nuage_de_mot_rtemis.html",
    "href": "Nuage_de_mot/nuage_de_mot_rtemis.html",
    "title": "Nuage de mot (R.temis)",
    "section": "",
    "text": "# ----- Librairies ----\nlibrary(\"R.temis\")\n\nWarning: le package 'R.temis' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : tm\n\n\nWarning: le package 'tm' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : NLP\n\n\nLe chargement a nécessité le package : slam\n\n\nLe chargement a nécessité le package : FactoMineR\n\n\nWarning: le package 'FactoMineR' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : explor\n\n\nWarning: le package 'explor' a été compilé avec la version R 4.2.3\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\n(N’oubliez pas d’installer les packages avant d’exéctuer les libraries si ceux-ci sont nouveaux!) Concernant le choix des données, j’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# ---- Import des données ----\n\ncorpus &lt;- import_corpus(\"genre.csv\",format=\"csv\",textcolumn=1,language=\"fr\")\n\nC’est quoi les stop_words?\nLes stop words (ou mots vides) sont des mots très courants dans un langage donné, comme les prépositions, les articles, les pronoms, etc., qui sont souvent omis lors de l’analyse de texte car ils ne portent pas de sens important pour la compréhension globale du texte.\n\n# ---- traitement des données ----\ndtmsmo &lt;-build_dtm(corpus, remove_stopwords = T, min_length = 0)\n\ndic &lt;-dictionary(dtmsmo) #création d'un dictionnaire de mot \n\nfrequent_terms(dtmsmo) #fréquence d'apparition des mots dans le texte en question\n\nIl est possible de faire un traitement plus poussé des données\n\n# ---- Générateur du Nuage ---- \ncloud&lt;-word_cloud(dtmsmo, color=brewer.pal(10, \"OrRd\"), min.freq=0) \n\nWarning in brewer.pal(10, \"OrRd\"): n too large, allowed maximum for palette OrRd is 9\nReturning the palette you asked for with that many colors\n\n\n\n\nterms_graph(dtmsmo, min_occ=1,interactive=T) #pour obtenir un graph de mots.\n\n[1] 1"
  },
  {
    "objectID": "Package_purrr/package_purrr.html",
    "href": "Package_purrr/package_purrr.html",
    "title": "Package Purrr",
    "section": "",
    "text": "purrr est un package dédié à la programmation fonctionnelle. Ses fonctions principales sont les fonctions map() (map(), map_chr(), map_dbl(), map_dfr(), etc…), elles permettent d’appliquer une même fonction (ou une même série de fonctions) à chaque élément d’un ensemble (les colonnes d’un data frame, ou les éléments d’une list par exemple). En gros, ces fonctions map() permettent de remplacer les boucles for() avantageusement en termes de nombre de lignes de code et de temps de calcul (parce que ces fonctions reposent sur la récursivité).\n\nlibrary(purrr) \n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nA titre d’exemple on va essayer de supposer que nous avons une liste de vecteurs numériques et que nous allons appliquer une fonction à chaque vecteur pour en extraire la valeur maximale. Sans le package purr il est nécessaire d’utiliser une boucle for:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Initialiser un vecteur vide pour stocker les résultats\nmax_vals &lt;- numeric(length(my_list))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nfor (i in seq_along(my_list)) {\n  max_vals[i] &lt;- max(my_list[[i]])\n}\n# Afficher les résultats\nmax_vals\n\n[1] 3 6 9\n\n\nAvec le package purrr:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nmax_vals &lt;- map(my_list, max)\n\n# Afficher les résultats\nmax_vals\n\non remarque qu’on gagne quand même pas mal de temps d’écriture en utilisant le package purrr, ce qui peut vraiment servir quand on a de pas mal de ligne de code.\n\n\nPour en apprendre plus sur le package purr :\nhttps://delladata.fr/liste-de-ressources-pour-le-package-purrr/"
  },
  {
    "objectID": "Package_rio/Rio_package.html",
    "href": "Package_rio/Rio_package.html",
    "title": "Package Rio",
    "section": "",
    "text": "L’import de données est la base de tout programme informatique portant sur le traitement de données. Le package “rio” est une collection de fonctions pour importer et exporter des données dans différents formats avec R. Il permet d’importer facilement des fichiers de données à partir de diverses sources, notamment des fichiers plats, des bases de données, des fichiers SAS, SPSS et Stata, ainsi que des fichiers Excel et RData. Il faut au préalable installer le package avec la commande suivante: ” install.packages(“rio”)“.\n\n# ---- Librairie ---- \n\nlibrary(rio)\n\nWarning: le package 'rio' a été compilé avec la version R 4.2.3\n\ninstall_formats()\n\n[1] TRUE\n\n# --- import de données --- \n\n#Pour des données au format xlsx\n\ndata_xslx&lt;-import(\"election_leg.xlsx\") \n\n\n#Pour des données au format SAS (ou autre), c'est la même chose.\ndata_sas&lt;-import(\"chemin_d_acces.sas7bdat\")\n\nPour exporter une base de données dans un fichier, il est recommandé d’utiliser la méthode “export” en utilisant le dataframe que vous voulez exporter, ici “data_sas” (comme illustré ci-dessous), et en spécifiant le chemin où vous souhaitez le sauvegarder. Cette méthode est généralement utilisée lorsque vous apportez des modifications directes à votre dataframe et que vous souhaitez enregistrer les changements quelque part.\n\n# --- export de données ---\n\nchemin_acces&lt;-export(data_sas,\"election_leg.xlsx\")\n\nPour en apprendre plus sur le package rio https://rdocumentation.org/packages/rio/versions/0.5.29\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "Package_dplyr/quarto_dplyr.html",
    "href": "Package_dplyr/quarto_dplyr.html",
    "title": "Package Dplyr",
    "section": "",
    "text": "Nous utiliserons dplyr comme package. dplyr est une grammaire de manipulation de données, fournissant un ensemble cohérent de verbes qui vous aide à résoudre les problèmes de manipulation de données les plus courants. https://www.rdocumentation.org/packages/dplyr/versions/0.7.8\n\n# ---- Librairie nécessaire pour le code ----\nlibrary(dplyr) \n\nWarning: le package 'dplyr' a été compilé avec la version R 4.2.3\n\nlibrary(tidyverse) #pour utiliser \"%&gt;%\" (ou pipe) définit en dessous\n\nWarning: le package 'tidyverse' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'ggplot2' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'tibble' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'stringr' a été compilé avec la version R 4.2.3\n\n\nUne fois la librairie importée, nous devons importer les donnés pour pouvoir travailler dessus. Nous utilisons ici un exemple de fichier de traitement de données portant sur le titanic. Nous utiliserons le package Rio pour les importer.\n\ndata(starwars)\n\nMais comment puis-je filtrer ma table pour n’obtenir que les passagers situé dans la classe 2 à bord du titanic ?\nLe “pipe” ou opérateur “%&gt;%” en R permet d’enchaîner les opérations sur une table sans avoir à répéter le nom de la table à chaque étape. Cela simplifie la syntaxe et rend le code plus lisible en permettant d’écrire des enchaînements d’opérations sur une table de manière plus concise et efficace.\n\nstarwars&lt;-starwars %&gt;% filter(species==\"Human\")\n# sans l'opérateur %&gt;% on aurait : \nstarwars_filtered &lt;- filter(starwars, species == \"Human\")\n# une autre façon de filter sans utiliser le package dplyr est \nstarwars_filtered &lt;- starwars[starwars$species == \"Human\", ]\n\nComment est-ce que je peut ajouter des données à mon dataframe?\n\n#avec dplyr on utilise la fonction mutate() pour ajouter des colonnes\n# a notre dataframe. Pour afficher la nouvelle colonne dans le dataframe \n#on rajoute la commande select(nouvelle_colonne,everything())\nstarwars %&gt;% mutate(moyenne=mean(is.na(mass))) %&gt;% select(moyenne,everything())\n\nComment est-ce que je peux selectionner uniquement les colonnes qui m’interesse pour mon travail?\n\nstarwars %&gt;% select(species,gender) #on selectionne ici l'espèce et le genre\n\nComment est-ce que je peux grouper mes données ?\n\nstarwars %&gt;% group_by(species) # regroupe par espèce\n\n#La fonction tapply() est une autre fonction de base de R \n#qui permet de regrouper les données selon une ou plusieurs variables\navg_height_by_species &lt;- tapply(starwars$height, starwars$species, mean, na.rm = TRUE)\n\n#La fonction aggregate() est une fonction de base de R qui permet de regrouper les données selon une ou plusieurs variables \navg_height_by_species &lt;- aggregate(starwars$height, by = list(starwars$species), FUN = mean, na.rm = TRUE)\n\nPour en apprendre plus sur dplyr :\nhttps://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html"
  },
  {
    "objectID": "R/Nuage_de_mot/nuage_de_mot.html",
    "href": "R/Nuage_de_mot/nuage_de_mot.html",
    "title": "Nuage de mot (Tm)",
    "section": "",
    "text": "Comme dans tout bon code R il est nécessaire au début d’installer (une fois sur un ordinateur): (dans le terminal de commande ) install.packages(“tm”) # pour le text mining install.packages(“SnowballC”) # pour le text stemming install.packages(“wordcloud”) # générateur de word-cloud install.packages(“RColorBrewer”) # Palettes de couleurs les packages recquis pour le code et de charger (à chaque fois ) les librairies requisent pour le code.\n\n# ---- library ----\nlibrary(\"tm\") # pour le text mining\n\nWarning: le package 'tm' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : NLP\n\nlibrary(\"SnowballC\") # pour le text stemming\n\nWarning: le package 'SnowballC' a été compilé avec la version R 4.2.3\n\nlibrary(\"wordcloud\") # générateur de word-cloud \n\nWarning: le package 'wordcloud' a été compilé avec la version R 4.2.3\n\n\nLe chargement a nécessité le package : RColorBrewer\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\nLe text-mining (ou fouille de texte) est une technique d’analyse de données qui consiste à extraire des informations significatives à partir de données textuelles non structurées telles que des documents, des e-mails, des pages web, des tweets, etc.\nLe stemming est une technique de traitement automatique du langage naturel (TALN) qui consiste à réduire les mots à leur forme racine ou à leur base lexicale, en éliminant les suffixes ou les terminaisons des mots. Par exemple, le stemming pourrait transformer les mots “manger”, “mangeais” et “mangé” en leur forme racine “mang”.\nJ’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# Lire le fichier texte\nfilePath &lt;- \"genre.txt\"\ntext &lt;- readLines(filePath)\n\nWarning in readLines(filePath): ligne finale incomplète trouvée dans\n'genre.txt'\n\n# Charger les données comme un corpus\ndocs &lt;- Corpus(VectorSource(text))\n\nPar la suite, il faut transformer un peu le texte pour ne gardez que l’essentiel, le coeur du sujet. Il faut donc supprimer les “stopword” (le,la,une,des,…).\n\n# ---- Transofrmation du texte ----\n\ntoSpace &lt;- content_transformer(function (x , pattern ) gsub(pattern, \" \", x)) \n\n# Convertir le texte en minuscule\ndocs &lt;- tm_map(docs, content_transformer(tolower)) \n\nWarning in tm_map.SimpleCorpus(docs, content_transformer(tolower)):\ntransformation drops documents\n\n# Supprimer les mots vides anglais\ndocs &lt;- tm_map(docs, removeWords, stopwords(\"fr\"))\n\nWarning in tm_map.SimpleCorpus(docs, removeWords, stopwords(\"fr\")):\ntransformation drops documents\n\n# Supprimer votre propre liste de mots non désirés\ndocs &lt;- tm_map(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")) \n\nWarning in tm_map.SimpleCorpus(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")):\ntransformation drops documents\n\n# Supprimer les ponctuations\ndocs &lt;- tm_map(docs, removePunctuation)\n\nWarning in tm_map.SimpleCorpus(docs, removePunctuation): transformation drops\ndocuments\n\n# Supprimer les espaces vides supplémentaires\ndocs &lt;- tm_map(docs, stripWhitespace)\n\nWarning in tm_map.SimpleCorpus(docs, stripWhitespace): transformation drops\ndocuments\n\ninspect(docs) #inspecter le document\n\nS’il on veut supprimer des nombres, on utilise la syntaxe : “docs &lt;- tm_map(docs, removeNumbers)”\nOn réalise ensuite une table de fréquence d’apparition des mots\n::: {.cell}\n# table de fréquence de mot (voir table d'occurence)\ndtm &lt;- TermDocumentMatrix(docs)\nm &lt;- as.matrix(dtm)\nv &lt;- sort(rowSums(m),decreasing=TRUE)\nd &lt;- data.frame(word = names(v),freq=v)\nhead(d, 12) # affiche les 12 mots avec les plus grosses fréquences. \n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=brewer.pal(8, \"Paired\")) #réalisation du nuage de mots.\n::: {.cell-output-display}  :::\n# On pourrait faire quelque chose de beaucoup plus neutre en terme de couleur avec la commande :\n\n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=\"black\")\n::: {.cell-output-display}  ::: :::\nC’est quoi le set.seed(1234) ? Lorsque vous utilisez une graine aléatoire (le set.seed(1234)), cela garantit que les résultats de votre analyse seront les mêmes à chaque fois que vous exécutez le code. Cela est particulièrement important lorsque vous travaillez avec des fonctions qui impliquent une certaine forme d’aléatoire, comme la génération de nuages de mots.\nAinsi, si vous utilisez la même graine aléatoire (par exemple, 1234) dans votre code chaque fois que vous exécutez l’analyse, vous obtiendrez toujours les mêmes résultats, ce qui facilite la reproductibilité de votre analyse. Sans fixer la graine aléatoire, la génération du nuage de mots peut varier à chaque exécution, car les fonctions qui génèrent le nuage de mots utilisent généralement des algorithmes aléatoires pour placer les mots dans l’espace et choisir les couleurs. Cela signifie que chaque fois que vous exécutez le code, vous obtiendrez un nuage de mots différent, même si les données d’entrée sont les mêmes.\nPour en apprendre plus sur la constrcution des images de mots : http://www.sthda.com/french/wiki/text-mining-et-nuage-de-mots-avec-le-logiciel-r-5-etapes-simples-a-savoir"
  },
  {
    "objectID": "R/Nuage_de_mot/nuage_de_mot_rtemis.html",
    "href": "R/Nuage_de_mot/nuage_de_mot_rtemis.html",
    "title": "Générer un nuage de mot à partir d’un texte avec R.temis",
    "section": "",
    "text": "1. Travail préliminaire\nLes packages “R.temis”, “dplyr” et “tibble” sont nécessaires pour ce code car ils contiennent des fonctions et des outils qui sont utilisés pour manipuler et analyser les données textuelles.\nLe package “R.temis” fournit des fonctions pour le traitement du langage naturel, telles que la lemmatisation, la tokenisation et l’analyse de sentiment. Ces fonctions sont utilisées dans le code pour analyser les tweets et extraire les mots clés.\nLe package “dplyr” fournit des fonctions pour la manipulation de données, telles que la sélection de colonnes, le filtrage de données et l’agrégation de données. Ces fonctions sont utilisées dans le code pour nettoyer et préparer les données textuelles.\nLe package “tibble” fournit une classe de données pour stocker des données tabulaires, qui est plus efficace que la classe de données par défaut de R. Cette classe de données est utilisée dans le code pour stocker les données textuelles nettoyées et préparées.\nIl est nécessaire d’installer ces packages une fois sur un ordinateur, car ils ne sont pas inclus dans l’installation de base de R. Ensuite, les packages doivent être chargés à chaque fois que le code est exécuté en utilisant la fonction “library”. Cela permet d’utiliser les fonctions et les outils fournis par les packages dans le code.\ninstall.packages(“R.temis”) install.packages(“dplyr”) install.packages(“tibble”)\n\nlibrary(\"R.temis\")\nlibrary(\"dplyr\") #Pour le traitement du texte voir la fiche \"Faciliter la manipulation de données avec Dplyr\".\nlibrary(\"tibble\")\n\nConcernant le choix des données, j’ai choisis les voeux de François Hollande allant de 2013 à 2017. Les textes retranscrits dans des fichiers de type texte (.txt) et placé dans un seul dossier nommé dossier_de_texte. Il est important de vérifer l’encodage de vos textes pour la suite du code. Ici, l’encodage est UTF-8.\n\ncorpus &lt;- import_corpus(\"dossier_de_texte\", format=\"txt\", language =\"fr\")\n\n\n\n2. Nettoyage du texte\nC’est quoi les stop_words?\nLes stop words (ou mots vides) sont des mots très courants d’une langue comme les prépositions, les articles, les pronoms, etc., qui sont souvent omis lors de l’analyse de texte car en général ils ne portent pas de sens important pour la compréhension globale du texte. La fonction build_dtm est utilisée pour construire une matrice de termes-document (ou tableau lexical) à partir d’un corpus de textes. La matrice de termes-document (ou Tableau Lexical) est une représentation quantitative d’un corpus de textes, où chaque colonne représente un terme et chaque ligne représente un document.\n\n# Création du tableau lexical sans mots outils et avec les mots d’au moins 1 lettre\ndtm &lt;-build_dtm(corpus, remove_stopwords = T, min_length = 1)\n# Création d'un dictionnaire de mot\ndic &lt;-dictionary(dtm) \n# Calcul des occurrences des mots dans le corpus de textes\nfrequent_terms(dtm) \n\n             Global occ.  Global %\nfrance                66 1.9446081\na                     54 1.5910430\nplus                  48 1.4142605\nannée                 33 0.9723041\nêtre                  29 0.8544490\naussi                 28 0.8249853\npays                  24 0.7071302\ntous                  24 0.7071302\ntout                  24 0.7071302\ncontre                19 0.5598114\ncompatriotes          18 0.5303477\nfaire                 18 0.5303477\ndoit                  17 0.5008839\nface                  16 0.4714202\ntoutes                16 0.4714202\nchers                 15 0.4419564\nveux                  15 0.4419564\neurope                14 0.4124926\ncomme                 13 0.3830289\nemploi                13 0.3830289\nmonde                 13 0.3830289\nconfiance             12 0.3535651\nparce                 12 0.3535651\nrépublique            12 0.3535651\nceux                  11 0.3241014\n\n\n\n\n3. Traitement du corpus\nJ’aimerais aussi retirer les mots “a” et “plus” et rassembler sous un même mot les termes “tout”, “toutes” et “tous” en “tous.tes” à titre d’exemple.\n\ndic2 = dic %&gt;%\n  rownames_to_column(var=\"word\") %&gt;% \n  mutate(Term = word)\n\nrow.names(dic2) &lt;- dic2$word\n\n# Remplacer les mots spécifiés par tous.tes\ndic2$Term[dic2$word == \"toutes\"] &lt;- \"tous.tes\"\ndic2$Term[dic2$word == \"tout\"] &lt;- \"tous.tes\"\ndic2$Term[dic2$word == \"tous\"] &lt;- \"tous.tes\"\n\n# Lemmatisation\ndtmlem &lt;-combine_terms(dtm, dic2)\n\n# Ensemble de mots à retirer\nmots_a_retirer &lt;- c(\"a\", \"plus\")\n\n# Suppression de mots dans le tablrau lexical\ndtm2&lt;-dtmlem[, !colnames(dtmlem) %in% mots_a_retirer]\n\n\nfrequent_terms(dtm2)\n\n             Global occ.  Global %\nfrance                66 2.0048603\ntous.tes              64 1.9441069\nannée                 33 1.0024301\nêtre                  29 0.8809235\naussi                 28 0.8505468\npays                  24 0.7290401\ncontre                19 0.5771567\ncompatriotes          18 0.5467801\nfaire                 18 0.5467801\ndoit                  17 0.5164034\nface                  16 0.4860267\nchers                 15 0.4556501\nveux                  15 0.4556501\neurope                14 0.4252734\ncomme                 13 0.3948967\nemploi                13 0.3948967\nmonde                 13 0.3948967\nconfiance             12 0.3645200\nparce                 12 0.3645200\nrépublique            12 0.3645200\nceux                  11 0.3341434\nentre                 11 0.3341434\nentreprises           11 0.3341434\nlà                    11 0.3341434\nsoir                  11 0.3341434\n\n\n#4. Affichage du Nuage de mot\nCe graphique permet de visualiser les mots les plus fréquents d’un corpus de textes (et préciser que tu as supprimé des mots, tu en as regroupés …)\n\n# On affiche au maximum 50 mots et les mots d’au moins une occurrence\ncloud&lt;-word_cloud(dtm2, color= 'black', min.freq=1,n =50) \n\n\n\n\n\n\n5. Affichage d’un graphe de mots\nLa fonction terms_graph du package R.temis permet de générer un réseau de mots qui est affiché dans une fenêtre interactive igraph. Les termes ou mots sont représentés par des sommets ou nœuds dans le graphe, les liens représentent les cooccurrences entre les mots dans les documents. Leur placement dans l’espace graphique est déterminé par un algorithme d’énergie. Ici,ce n’est pas très représentatif mais ça donne globalement une idée de ce que peut nous fournir un tel graphe: l’idée globale des thématiques et des sujets traités dans le corpus.\n\n# Créer un graphique d'analyse de co-occurrences de termes\nTree&lt;-terms_graph(dtm2, min_occ = 10, interactive = T,\n            vertex.size = 0.01, vertex.color = \"lightblue\",\n            label.cex = 0.1)\n\n\n\n\n6. Pour aller plus loin\nhttps://rtemis.hypotheses.org/r-temis-dans-rstudio"
  },
  {
    "objectID": "R/Package_dplyr/quarto_dplyr.html",
    "href": "R/Package_dplyr/quarto_dplyr.html",
    "title": "Faciliter la manipulation de données avec Dplyr",
    "section": "",
    "text": "Nous utiliserons dplyr comme package. dplyr est une grammaire de manipulation de données, fournissant un ensemble cohérent de verbes qui vous aide à résoudre les problèmes de manipulation de données les plus courants. https://www.rdocumentation.org/packages/dplyr/versions/0.7.8\n\n# ---- Librairie nécessaire pour le code ----\nlibrary(dplyr) \n\nWarning: le package 'dplyr' a été compilé avec la version R 4.2.3\n\nlibrary(tidyverse) #pour utiliser \"%&gt;%\" (ou pipe) définit en dessous\n\nWarning: le package 'tidyverse' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'ggplot2' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'tibble' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nWarning: le package 'stringr' a été compilé avec la version R 4.2.3\n\n\nUne fois la librairie importée, nous devons importer les donnés pour pouvoir travailler dessus. Nous utilisons ici un exemple de fichier de traitement de données portant sur le titanic. Nous utiliserons le package Rio pour les importer.\n\ndata(starwars)\n\nMais comment puis-je filtrer ma table pour n’obtenir que les passagers situé dans la classe 2 à bord du titanic ?\nLe “pipe” ou opérateur “%&gt;%” en R permet d’enchaîner les opérations sur une table sans avoir à répéter le nom de la table à chaque étape. Cela simplifie la syntaxe et rend le code plus lisible en permettant d’écrire des enchaînements d’opérations sur une table de manière plus concise et efficace.\n\nstarwars&lt;-starwars %&gt;% filter(species==\"Human\")\n# sans l'opérateur %&gt;% on aurait : \nstarwars_filtered &lt;- filter(starwars, species == \"Human\")\n# une autre façon de filter sans utiliser le package dplyr est \nstarwars_filtered &lt;- starwars[starwars$species == \"Human\", ]\n\nComment est-ce que je peut ajouter des données à mon dataframe?\n\n#avec dplyr on utilise la fonction mutate() pour ajouter des colonnes\n# a notre dataframe. Pour afficher la nouvelle colonne dans le dataframe \n#on rajoute la commande select(nouvelle_colonne,everything())\nstarwars %&gt;% mutate(moyenne=mean(is.na(mass))) %&gt;% select(moyenne,everything())\n\nComment est-ce que je peux selectionner uniquement les colonnes qui m’interesse pour mon travail?\n\nstarwars %&gt;% select(species,gender) #on selectionne ici l'espèce et le genre\n\nComment est-ce que je peux grouper mes données ?\n\nstarwars %&gt;% group_by(species) # regroupe par espèce\n\n#La fonction tapply() est une autre fonction de base de R \n#qui permet de regrouper les données selon une ou plusieurs variables\navg_height_by_species &lt;- tapply(starwars$height, starwars$species, mean, na.rm = TRUE)\n\n#La fonction aggregate() est une fonction de base de R qui permet de regrouper les données selon une ou plusieurs variables \navg_height_by_species &lt;- aggregate(starwars$height, by = list(starwars$species), FUN = mean, na.rm = TRUE)\n\nPour en apprendre plus sur dplyr :\nhttps://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html"
  },
  {
    "objectID": "R/Package_mapsf/map_sf.html",
    "href": "R/Package_mapsf/map_sf.html",
    "title": "Produire des cartes thématiques avec Mapsf",
    "section": "",
    "text": "Nous allons réaliser des cartes avec R à l’aide du package “mapsf” et du packages “sf”. Le package “mapsf” est un outil très utile pour manipuler et visualiser des données spatiales en R, tandis que le package “sf” fournit une infrastructure pour stocker et manipuler ces données. Ces deux packages sont très utiles pour travailler avec des données spatiales dans R, ce qui en fait un choix idéal pour créer des cartes et réaliser des analyses spatiales.\n\nlibrary(mapsf)\nlibrary(sf)\nlibrary(dplyr)\n\nNous allons réaliser une carte de Paris. Pour cet exemple, j’ai récupéré les données sur le site de Paris Data : https://opendata.paris.fr/pages/catalogue/?disjunctive.theme&disjunctive.publisher\nAffichage du fond de carte correspondant aux limites des arrondissements auquel je vais ajouter les voies d’eau en couche d’habillage.\n\n# ----- Import des données -----\n\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr' \n  using driver `GeoJSON'\nSimple feature collection with 20 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2.224078 ymin: 48.81558 xmax: 2.469761 ymax: 48.90216\nGeodetic CRS:  WGS 84\n\ncours_deau&lt;-st_read(dsn=\"https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin\")\n\nReading layer `OGRGeoJSON' from data source \n  `https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/plan-de-voirie-voies-deau/exports/geojson?lang=fr&timezone=Europe%2FBerlin' \n  using driver `GeoJSON'\nSimple feature collection with 58 features and 25 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.224081 ymin: 48.81924 xmax: 2.450555 ymax: 48.90207\nGeodetic CRS:  WGS 84\n\n\n\n#Dans un premier temps je réalise mon fond de carte avec les arrondissements de Paris \nmf_map(x = arrondissements, border = \"black\") \n\n#Je rajoute la couche des cours d'eau sur mon fond de carte avec l'argument \"add=TRUE\"\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\n\n\n\n\n\n# d'un point de vue esthétique je choisis d'appliquer un fond noir à mes cartes\nmf_theme(\"darkula\")\n\n\nLes différents types de cartes\n\n\n\nLes cartes à symboles proportionnels\nLa carte en symboles proportionnels est la méthode de représentation graphique à utiliser pour visualiser des variables de stocks (variables quantitatives absolues pour lesquelles la somme et la moyenne ont une signification).\nSur la carte, j’affiche l’effectif de la population de chaque arrondissement et j’ajoute la légende et un titre.\n\narrondissements$pop &lt;- c(1012687, 903036, 1369857, 1491027, 1672009, 1506475, 1637163, 1603380, 1637542, 1059282, 1494945, 1436205, 1705774, 1425805, 236769, 1668605, 1674568, 1539668, 1421827, 1829526) #INSEE,2021\nmf_map(x = arrondissements)\nmf_map(x=cours_deau,lwd=2,border=\"lightblue\",col=\"lightblue\",add=TRUE)\nmf_map(\n  x = arrondissements,\n# variable à représenter: population des arrondissements\n  var = \"pop\",\n# type de carte : symboles proportionnels\n  type = \"prop\",\n  leg_title = \"Population totale\\12 271 794\",\n  col=\"blue\",\n  add= TRUE,\n  inches=0.2)\n\nmf_title(\"Distribution de la population dans Paris\")\n\n\n\n\n# Les cartes choroplèthes\nLa carte choroplèthe est la représentation graphique à utiliser pour visualiser des ratios (des variables quantitatives relatives pour lesquelles la moyenne a un sens, mais dont la somme n’a pas de sens) qui sont des variables qualitatives ordinales.\nSur la carte, j’affiche la densité de population de chaque arrondissement. J’utilise la méthode des quantiles pour discréditer cette variable et j’utilise une palette de couleur avec dégradé pour représenter l’ordre entre mes valeurs.\n\n#création de la variable densite \narrondissements$DENS &lt;- 1e6 * arrondissements$pop / as.numeric(st_area(arrondissements))\nmf_map(\n  x = arrondissements,\n# variable à représenter: densité de population  \nvar = \"DENS\",\n# type de carte  \ntype = \"choro\",\n# méthode de dsicrétisation\n  breaks = \"quantile\",\n# palette de rouges  \npal = \"Reds\",\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  leg_val_rnd = 0\n)\n\n\n\n\nRemarque: la faible densité de population des 12e et 16e arrondissement est faible, notamment en raison des bois de Vincennes et de Boulogne qui les composent.\nOn peut aussi représenter un autre type de variable: qualitative nominale ici les bords politiques des mairies de chaque arrondissement. Pour cela, on produit une carte choroplèthes mais avec des couleurs «sans dégradé»\n\nbords_politiques &lt;- c(\"PS\", \"EELV\", \"PS\", \"PS\", \"DVD\", \"LR\", \"LR\", \"LR\", \"DVD\", \"PS\", \"PS\", \"PS\", \"PS\", \"EELV\", \"LR\", \"LR\", \"LR\", \"PS\", \"PS\", \"EELV\")\narrondissements &lt;- cbind(arrondissements, bords_politiques)\n\n# choix des couleurs\n\ncolors &lt;- c(\"PS\" = \"#FF0066\", \"EELV\" = \"#00CC66\", \"DVD\" = \"#FF9933\", \"LR\" = \"#0066CC\")\n\n# Pour placer les carrés sur les centroïdes des polygones représentant les arrondissements.\n\narr_c&lt;-st_centroid(arrondissements)\n\nWarning: st_centroid assumes attributes are constant over geometries\n\nmf_map(x = arrondissements, border = \"black\")\n\n# Ajouter des triangles remplis pour chaque arrondissement en fonction de son bord politique\nmf_map(\n  x = arr_c,\n# var à représenter  \n var = \"bords_politiques\",\n  pch = 15,\n  cex = 2,\n  col = colors,\n  lwd = 1,\n  leg_title = \"Densité de population\\n(habitants par km2)\", \n  digits = 0,\n  add = TRUE\n)\n\nPlease use the 'type' argument to map variables.\n\n\n\n\n\n\n\nEt si on regroupait deux arrondissement ?\nPour cet exemple nous prenons le cas où, dans les statistiques que nous avons à représenter, les données, des 15e et 16e doivent être sommées. Il faut que les polygones du fond de carte représentant ces deux arrondissements soient alors aussi fusionnés.\nL’idée globale du code ci-dessous c’est de fusionner les deux polygones (celui du 15e Vaugirard et du 16e Passy).\nQuand je crée mon nouveau polygone (new_poly) j’ai une nouvelle geometrie “POLYGON” qui a concaténné les deux arrondissements. J’ai donc sur une ligne, toutes les informations relatives à mes deux polygones et en plus, une geometrie commune.\n\n# ---- Fusionner deux polygones ---- #\n\n# Sélectionner les deux polygones que vous souhaitez fusionner\npoly1 &lt;- arrondissements[arrondissements$l_aroff == \"Passy\", ] # sélectionne le polygone avec le nom \"Passy\"\npoly2 &lt;- arrondissements[arrondissements$l_aroff == \"Vaugirard\", ] # sélectionne le polygone avec le nom \"Vaugirard\"\n\n# Fusionner les polygones\nnew_poly &lt;- st_union(poly1, poly2) # fusionne les deux polygones sélectionnés en un seul polygone\n\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n\n# Ajouter la surface, la population, le périmètre et les coordonnées géographiques des deux polygones \n\n#l'idée c'est de recréer une nouvelle ligne pour notre nouveau polygone pour qu'on puisse le réinsérer dans notre tableau. \n\nnew_poly$surface &lt;- new_poly$surface + new_poly$surface.1 # ajouter la surface des deux polygones\nnew_poly$n_sq_co &lt;- new_poly$n_sq_co + new_poly$n_sq_co.1 # ajouter la population des deux polygones\nnew_poly$perimetre &lt;- new_poly$perimetre + new_poly$perimetre.1 # ajouter le périmètre des deux polygones\nnew_poly$n_sq_ar &lt;- new_poly$n_sq_ar + new_poly$n_sq_ar.1 # ajouter les coordonnées géographiques des deux polygones\n\nnew_poly$pop&lt;-new_poly$pop+ new_poly$pop.1\n\nnew_poly$DENS&lt;-new_poly$DENS+new_poly$DENS.1\n\n# Modifier les informations de localisation\nnew_poly$l_aroff &lt;- \"un nouvel arrondissement\" # changer le nom de l'arrondissement\nnew_poly$l_ar &lt;- \"xxème Ardt\" # changer le numéro de l'arrondissement\nnew_poly$c_ar &lt;- \"xx\" # changer le code de l'arrondissement\nnew_poly$c_arinsee &lt;- \"75xxxx\" # changer le code INSEE de la commune\nnew_poly$bords_politiques&lt;-\"PS\" #changer le bord politique du nouvel arrondissement\n\n\n# Sélectionner certaines colonnes pour créer un nouvel objet de données\narrondissements_test &lt;- subset(new_poly, select = c(c_ar, l_aroff, surface, l_ar, n_sq_co, c_arinsee, n_sq_ar, perimetre, geom_x_y,pop, DENS,bords_politiques))\n# à noter qu'il est très important de mettre les éléments dans le même ordre que celui du tableau\n\n# Remplacer les informations de l'arrondissement \"Passy\" dans l'objet \"arrondissements\" par les nouvelles informations et supprimer la ligne correspondant à l'arrondissement du  15e. \n\narrondissements[arrondissements$l_aroff == \"Passy\", ] &lt;- arrondissements_test\narrondissements &lt;- arrondissements[-which(arrondissements$c_ar == \"15\"),]\n\n\n# Afficher la carte de l'objet \"arrondissements\" avec les contours en noir\nmf_map(x = arrondissements,border= \"black\")\nmf_map(x = arrondissements,\n# variable à représenter: population des arrondissements\n  var = \"pop\",\n# type de carte : symboles proportionnels\n  type = \"prop\",\n  leg_title = \"Population totale\\12 271 794\",\n  col=\"blue\",\n  add= TRUE,\n  inches=0.2)\n\n\n\n\n\n\nEn savoir plus sur mapsf:\nPour la rédaction de cet article je me suis grandement inspirée du travail de Timothée Giraud.\nhttps://rcarto.github.io/ined2022/07_mise_en_page.html\nhttp://riatelab.github.io/mapsf\nhttp://rgeomatic.hypotheses.org/2077"
  },
  {
    "objectID": "R/Package_mapsf/R_cartographie.html",
    "href": "R/Package_mapsf/R_cartographie.html",
    "title": "Afficher des cartes interactives avec Mapview",
    "section": "",
    "text": "Nous allons vous présenter trois packages permettant de générer des cartes interactives : sf , mapview_. Il faut donc au préalable installer ces deux packages. install.packages(“sf”) install.packages(“mapview”) install.packages(“stringr”) #qui sera utilisé pour traiter les données.\n\nlibrary(\"sf\")\nlibrary(\"mapview\")\nlibrary(\"stringr\")\n\nDans un premier temps nous allons travailler avc __mapview__qui est une bibliothèque R qui permet d’afficher des données géospatiales interactives et de les explorer facilement. Elle offre une interface graphique conviviale qui permet de zoomer, de déplacer et de sélectionner des données géospatiales à l’aide de la souris.\nNous décidons de travailler sur Paris tout au long de ce tuto.\n\nOn télécharge les données des arrondissements de Paris à partir du site opendata.paris.fr et stocke les données dans l’objet arrondissements sous forme d’un objet de type sf (spatial).\n\n\n# Télécharger les données des arrondissements de Paris\narrondissements &lt;- st_read(dsn = \"https://opendata.paris.fr/explore/dataset/arrondissements/download/?format=geojson&timezone=Europe/Berlin&lang=fr\")\n\n\nOn convertit l’objet en un dataframe pour pouvoir travailler dessus.\n\n\n# Convertir l'objet sf en un data.frame\narrondissements_df &lt;- st_drop_geometry(arrondissements)\n\n\nOn supprime les colonnes qui ne sont pas nécessaires pour la représentation spatiale.\n\n\n# Supprimer les colonnes qui ne sont pas nécessaires pour la représentation spatiale\ncols_to_remove &lt;- c(\"datasetid\", \"recordid\", \"fields\", \"geometry_name\", \"type\")\narrondissements_df &lt;- arrondissements_df[, !(names(arrondissements_df) %in% cols_to_remove)]\n\n\nOn convertit les colonnes de type list en caractère et la liste en dataframe/\n\n\n# Convertir les colonnes de type list en caractère\narrondissements_df &lt;- lapply(arrondissements_df, function(x) if (is.list(x)) as.character(x) else x)\n\n# Convertir la liste en data.frame\narrondissements_df &lt;- as.data.frame(arrondissements_df)\n\n\nOn crée un exemple de données df composé de deux colonnes : ‘id’ et ‘coordinates’ (géocode et coordonées spatiale de chaque arrondissement.\n\nMes données sont sous la forme d’un vecteur c(a,b). Pour travailler plus simplement je travaille sur la colonne avec le vecteur en question pour créer deux colonnes latitude et longitude.\n\n# Exemple de données\ndf &lt;- data.frame(id = c(1, 2), coordinates = arrondissements_df$geom_x_y)\n\n\n# Diviser la chaîne de caractères à la virgule et extraire la deuxième partie\ncoord_vec &lt;- as.data.frame(strsplit(df$coordinates, \",\"))\ncoord_vec[1,] &lt;- gsub(\"c\", \"\", coord_vec[1,]) # je supprime le c\ncoord_vec[1,] &lt;- gsub('\\\\(', \"\", coord_vec[1,]) # je supprime la parenthèse\ncoord_vec[2,] &lt;- gsub('\\\\)', \"\", coord_vec[2,])\n\n\ncoord_vec[1,]&lt;- as.numeric(coord_vec[1,])\n\ncoord_vec[2,]&lt;- as.numeric(coord_vec[2,])\n\n\ncoord_vec_tranposee&lt;-t(coord_vec)\n\n# Afficher le résultat\narrondissements_df$lon&lt;-coord_vec_tranposee[,1]\narrondissements_df$lat&lt;-coord_vec_tranposee[,2]\n\n6 . L’affichage de la carte interactive\narrondissements_df est un data.frame qui contient des informations sur les arrondissements de Paris. Les colonnes lat et lon contiennent les coordonnées géographiques des centres de chaque arrondissement.\nLe paramètre crs est utilisé pour spécifier le système de coordonnées de référence (en l’occurrence, ici, le code EPSG 4326 qui correspond aux coordonnées géographiques de latitude et longitude).\nLa fonction mapview() prend en entrée l’objet sf arrondissements_sf, ainsi que le nom des colonnes à utiliser pour représenter les données (zcol). Dans cet exemple, les colonnes c_ar et l_aroff sont utilisées pour définir la couleur et l’étiquette de chaque arrondissement. La fonction mapview() crée ensuite une carte interactive que vous pouvez explorer en cliquant et en faisant glisser la souris pour changer le niveau de zoom et la vue.\n\n# Afficher les premières lignes du data.frame\narrondissements_sf &lt;- st_as_sf(arrondissements_df, coords = c(\"lat\",\"lon\"), crs=4326)\n# Retour au format sf pour appliquer la fonction mapview()\nmapview(arrondissements_sf, zcol = c(\"c_ar\",\"l_aroff\"))"
  },
  {
    "objectID": "R/Package_purrr/package_purrr.html",
    "href": "R/Package_purrr/package_purrr.html",
    "title": "Comment faire de la programmation fonctionelle avec Purrr",
    "section": "",
    "text": "purrr est un package dédié à la programmation fonctionnelle. Ses fonctions principales sont les fonctions map() (map(), map_chr(), map_dbl(), map_dfr(), etc…), elles permettent d’appliquer une même fonction (ou une même série de fonctions) à chaque élément d’un ensemble (les colonnes d’un data frame, ou les éléments d’une list par exemple). En gros, ces fonctions map() permettent de remplacer les boucles for() avantageusement en termes de nombre de lignes de code et de temps de calcul (parce que ces fonctions reposent sur la récursivité).\n\nlibrary(purrr) \n\nWarning: le package 'purrr' a été compilé avec la version R 4.2.3\n\n\nA titre d’exemple on va essayer de supposer que nous avons une liste de vecteurs numériques et que nous allons appliquer une fonction à chaque vecteur pour en extraire la valeur maximale. Sans le package purr il est nécessaire d’utiliser une boucle for:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Initialiser un vecteur vide pour stocker les résultats\nmax_vals &lt;- numeric(length(my_list))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nfor (i in seq_along(my_list)) {\n  max_vals[i] &lt;- max(my_list[[i]])\n}\n# Afficher les résultats\nmax_vals\n\n[1] 3 6 9\n\n\nAvec le package purrr:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nmax_vals &lt;- map(my_list, max)\n\n# Afficher les résultats\nmax_vals\n\non remarque qu’on gagne quand même pas mal de temps d’écriture en utilisant le package purrr, ce qui peut vraiment servir quand on a de pas mal de ligne de code.\n\n\nPour en apprendre plus sur le package purr :\nhttps://delladata.fr/liste-de-ressources-pour-le-package-purrr/"
  },
  {
    "objectID": "R/Package_rio/Rio_package.html",
    "href": "R/Package_rio/Rio_package.html",
    "title": "Package Rio",
    "section": "",
    "text": "L’import de données est la base de tout programme informatique portant sur le traitement de données. Le package “rio” est une collection de fonctions pour importer et exporter des données dans différents formats avec R. Il permet d’importer facilement des fichiers de données à partir de diverses sources, notamment des fichiers plats, des bases de données, des fichiers SAS, SPSS et Stata, ainsi que des fichiers Excel et RData. Il faut au préalable installer le package avec la commande suivante: ” install.packages(“rio”)“.\n\n# ---- Librairie ---- \n\nlibrary(rio)\n\nWarning: le package 'rio' a été compilé avec la version R 4.2.3\n\ninstall_formats()\n\n[1] TRUE\n\n# --- import de données --- \n\n#Pour des données au format xlsx\n\ndata_xslx&lt;-import(\"election_leg.xlsx\") \n\n\n#Pour des données au format SAS (ou autre), c'est la même chose.\ndata_sas&lt;-import(\"adherent.sas7bdat\")\n\nPour exporter une base de données dans un fichier, il est recommandé d’utiliser la méthode “export” en utilisant le dataframe que vous voulez exporter, ici “data_sas” (comme illustré ci-dessous), et en spécifiant le chemin où vous souhaitez le sauvegarder. Cette méthode est généralement utilisée lorsque vous apportez des modifications directes à votre dataframe et que vous souhaitez enregistrer les changements quelque part.\n\n# --- export de données ---\n\nchemin_acces&lt;-export(data_sas,\"election_leg.xlsx\")\n\nPour en apprendre plus sur le package rio https://rdocumentation.org/packages/rio/versions/0.5.29\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "R/Git/git.html",
    "href": "R/Git/git.html",
    "title": "Comment utiliser GitHub",
    "section": "",
    "text": "GitHub est une plateforme de développement collaboratif de logiciels qui facilite le partage, la gestion et la collaboration sur des projets de développement de logiciels.\n\n1. Créer un nouveau dépot\nRepository ou Projet ?\nun repository est l’endroit où est stocké le code source d’un projet, tandis qu’un projet est une fonctionnalité pour organiser les tâches, les problèmes et les notes liés à ce projet.\nNous allons créer un repository qui permmettra de stocker toutes les fiches R déjà faites. Il faut donc cliquer sur le petit plus dans la barre de navigation et selectionner “new repository”.\n\n\n\n2. Le repository\nPour créer le nouveau repository il faudra choisir un nom (repository name) Une description, une visibilité (publique ou privé).\nJe fais le choix d’ajouter directement le fichier README.md à mon repository. Le fichier README.md est un fichier texte présent à la racine d’un dépôt GitHub qui décrit le projet et fournit des informations importantes aux utilisateurs et aux contributeurs du projet. Le fichier README est généralement écrit en format Markdown, qui permet de formater le texte avec des titres, des listes, des liens, des images, etc.\n\nVoici ce que vous obtiendrez par la suite\n\n\n\n3. Un premier ajout de fichier\nIl faut a présent se placer dans votre terminal (VScode ou autre) et exectuer les commandes suivantes:\ngit init\nCette commande initialise un nouveau dépôt Git dans le répertoire courant. Elle crée un sous-répertoire nommé .git qui contient tous les fichiers nécessaires pour gérer le dépôt Git.\ngit add READ.md\nCette commande initialise un nouveau dépôt Git dans le répertoire courant. Elle crée un sous-répertoire nommé .git qui contient tous les fichiers nécessaires pour gérer le dépôt Git.\ngit commit -m “first commit”\nCette commande initialise un nouveau dépôt Git dans le répertoire courant. Elle crée un sous-répertoire nommé .git qui contient tous les fichiers nécessaires pour gérer le dépôt Git.\ngit branch -M main\nCette commande renomme la branche par défaut de “master” à “main”.\ngit remote add origin “https://github.com/nom_utilisateur/test_git.git”\nCette commande ajoute un nouveau référentiel Git distant appelé “origin”. Le nom “origin” est généralement utilisé pour le référentiel distant principal. L’URL est celle de votre dépôt GitHub et s’obtient en cliquant sur le petit bouton bleu code\ngit push -u origin main\nCette commande envoie les modifications du dépôt local vers le dépôt distant sur GitHub. L’option “-u” permet d’associer la branche locale “main” avec la branche distante “main” sur le référentiel “origin”. Cette étape ne sera nécessaire que pour le premier push, les pushs suivants, la commande sera simplement git push.\n\n\n4. Pour des ajouts réguliers\ngit add lien_du_fichier_a_ajouter\ngit commit -m “ajout du jour”\ngit push origin main\n\n\n5. Comment fusionner deux branches ?\nIci, on cherche à fusionner la branche main et master.\ngit checkout main\nCette commande change de branche pour la branche “main”. Cette commande doit être exécutée avant de fusionner la branche “master” pour s’assurer que les modifications sont apportées à la bonne branche.\ngit merge master\nCette commande fusionne la branche “master” avec la branche “main”. Si Git détecte un conflit entre les deux branches, il vous informera que la fusion ne peut pas être effectuée automatiquement et qu’il est nécessaire de résoudre le conflit manuellement.\ngit add lien_du_fichier_a_ajouter\ngit commit -m “resolution de conflit”\ngit push origin main"
  },
  {
    "objectID": "PowerShell/powershell.html",
    "href": "PowerShell/powershell.html",
    "title": "Comment utiliser PowerShell",
    "section": "",
    "text": "PowerShell, ou Windows PowerShell, anciennement Microsoft Command Shell (MSH), est une suite logicielle développée par Microsoft qui intègre une interface en ligne de commande, un langage de script nommé PowerShell ainsi qu’un kit de développement. Il est inclus depuis Windows 7 et s’appuie sur le framework Microsoft.NET.\nPour utiliser PowerShell, vous pouvez procéder de plusieurs manières. Par exemple, il est tout à fait possible de lancer PowerShell depuis l’invite de commande MS-DOS, comme je vous ai montré précédemment, en tapant powershell.\n\n$val= Read-Host \"Rentrer une chaîne de caractère\""
  },
  {
    "objectID": "R/SAS/fiche_import_SAS_formats.html",
    "href": "R/SAS/fiche_import_SAS_formats.html",
    "title": "Importer des fichiers SAS avec formats en R",
    "section": "",
    "text": "library(haven)\n\nWarning: le package 'haven' a été compilé avec la version R 4.2.3\n\nlibrary(dplyr)\n\nWarning: le package 'dplyr' a été compilé avec la version R 4.2.3\n\nlibrary(labelled)\n\nWarning: le package 'labelled' a été compilé avec la version R 4.2.3"
  },
  {
    "objectID": "R/SAS/fiche_import_SAS_formats.html#charger-les-librairies",
    "href": "R/SAS/fiche_import_SAS_formats.html#charger-les-librairies",
    "title": "Importer des fichiers SAS avec formats en R",
    "section": "",
    "text": "library(haven)\n\nWarning: le package 'haven' a été compilé avec la version R 4.2.3\n\nlibrary(dplyr)\n\nWarning: le package 'dplyr' a été compilé avec la version R 4.2.3\n\nlibrary(labelled)\n\nWarning: le package 'labelled' a été compilé avec la version R 4.2.3"
  },
  {
    "objectID": "R/SAS/fiche_import_SAS_formats.html#importer-un-fichier-sas",
    "href": "R/SAS/fiche_import_SAS_formats.html#importer-un-fichier-sas",
    "title": "Importer des fichiers SAS avec formats en R",
    "section": "Importer un fichier SAS",
    "text": "Importer un fichier SAS\nOn doit indiquer dans l’instruction read_sas le catalogue de formats après le nom de la table sas. Pour l’instant lorqu’on ouvre dans R le fichier “erfi_ext”, on ne voit pas les formats mais on a l’indication dans les labels. Toutes les variables associées à un format sas sont importées en variables character dans R.\n\nerfi_ext&lt;- read_sas(\"erfi_extrait2.sas7bdat\",catalog_file =\"formats.sas7bcat\")\nstr(erfi_ext$MB_STOC)\n\n chr+lbl [1:10079] 4, 4, 4, 1, 4, 2, 2, 2, 5, 4, 2, 4, 2, 2, 1, 2, 1, 1, 4,...\n @ label     : chr \"STATUT D'OCCUPATION\"\n @ format.sas: chr \"$MB_STOCF\"\n @ labels    : Named chr [1:5] \"1\" \"2\" \"3\" \"4\" ...\n  ..- attr(*, \"names\")= chr [1:5] \"Accédant à la propriété\" \"Propriétaire non accédant\" \"Usufruitier\" \"Locataire ou sous-locataire\" ..."
  },
  {
    "objectID": "R/SAS/fiche_import_SAS_formats.html#prise-en-compte-des-formats-sas",
    "href": "R/SAS/fiche_import_SAS_formats.html#prise-en-compte-des-formats-sas",
    "title": "Importer des fichiers SAS avec formats en R",
    "section": "Prise en compte des formats SAS",
    "text": "Prise en compte des formats SAS\nIl faut d’abord selectionner les colonnes avec formats, les convertir en factor et appliquer les formats SAS sur les valeurs.\n\nfor (col in names(erfi_ext)) {\n  if (!is.null(attr(erfi_ext[[col]], \"format\"))) {\n    erfi_ext &lt;- erfi_ext %&gt;%\n      mutate(!!col := as_factor(!!sym(col)))  \n  }\n  vide &lt;- which(erfi_ext[[col]] == \"\") \n  erfi_ext[[col]][vide] &lt;- NA \n}\n\nDésormais les valeurs des variables devenues “factor” sont sous format texte. Dans les 2 dernières lignes du code on corrige les valeurs vides par des NA.\nPour readapter ce code il faut juste changer “erfi_ext” par le nom de votre fichier importé.\n\nhead(erfi_ext)\n\n# A tibble: 6 × 18\n  IDENT poids12 MB_STOC MC_DIPLOME EA_VERIFC CA_MARIE OA_REPAS OA_VAISS OA_ALIME\n  &lt;dbl&gt;   &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;      &lt;fct&gt;     &lt;fct&gt;    &lt;fct&gt;    &lt;fct&gt;    &lt;fct&gt;   \n1     3   3038. Locata… 8          non       &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n2     7   2396. Locata… 6          non       &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n3     8   3064. Locata… 6          non       &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n4     9   3869. Accéda… 4          oui       non      Toujour… Toujour… Autant …\n5    11   3489. Locata… 8          non       &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;    \n6    15   4095. Propri… 4          oui       non      Le plus… Autant … Autant …\n# ℹ 9 more variables: OA_LINGE &lt;fct&gt;, OA_ASPIR &lt;fct&gt;, OA_BRICO &lt;fct&gt;,\n#   OA_SATREP &lt;chr&gt;, MA_SEXE &lt;fct&gt;, MA_LNAIS &lt;fct&gt;, MA_MNAIS &lt;dbl&gt;,\n#   MA_ANAIS &lt;dbl&gt;, MA_AGER &lt;fct&gt;\n\n\nIl reste un souci: seul les formats sas avec intervalles (exemple format groupe d’âge) n’ont pas pu s’importer correctement."
  },
  {
    "objectID": "R/SAS/fiche_import_SAS_formats.html#pour-les-intervalles-numeriques-a-revoir",
    "href": "R/SAS/fiche_import_SAS_formats.html#pour-les-intervalles-numeriques-a-revoir",
    "title": "Importer des fichiers SAS avec formats en R",
    "section": "Pour les intervalles numeriques ( A revoir!)",
    "text": "Pour les intervalles numeriques ( A revoir!)\nPour l’instant nous ne pouvons pas recupérer les formats sas numériques avec intervalles mais nous pouvons les recréer dans R “à la main” comme ci-dessous.\n\nerfi_ext$MA_AGER &lt;- cut(as.numeric(erfi_ext$MA_AGER), breaks = c(0, 35, 45, 55, Inf), \n                   labels = c(\"17-35 ans\", \"36-45 ans\", \"46-55 ans\", \"56 ans et plus\"))\n\nUne autre solution serait de créer dans SAS de nouvelles variables avec intervalles (format “en dur”) Exemple dans une etape data SAS:\ndata erfi_ext;\nset erfi_extrait2;\nclasse_age=put(MA_AGER,$age4c.);\nrun;\nLa nouvelle variable classe_age prendra les valeurs des intervalles définies dans le format créé “$age4c”. Quand on l’importera dans R, nous aurons une variable d’âge continu “MA_AGER” et une variable avec des classes d’âge (“classe_age”)."
  }
]